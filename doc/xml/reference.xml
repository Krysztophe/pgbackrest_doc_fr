<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc title="{[project]} Guide de référence des commandes &amp; de la configuration">
    <!-- CONFIG -->
    <config title="{[project]} Référence de la configuration">
        <description>Ce guide de référence de la configuration {[projet]} détaille toutes les options de configuration.</description>

        <text><backrest/> peut être utilisé entièrement avec les paramètres de la ligne de commande mais un fichier de configuration est plus pratique pour les installations complexes ou comportant beaucoup d'options. L'emplacement par défaut du fichier de configuration est <file>/etc/pgbackrest/pgbackrest.conf</file>.  Si aucun fichier n'existe à cet emplacement, l'ancienne valeur par défaut <file>/etc/pgbackrest.conf</file> sera alors utilisée.</text>

        <config-section-list title="Paramètres">
            <!-- CONFIG - LOG -->
            <config-section id="log" name="Log">
                <text>La section <setting>log</setting> définit les paramètres liés à la journalisation des traces.<admonition type="caution">Cette journalisation peut révéler des informations sensibles telles que des clés et des mots de passe.  À utiliser donc avec prudence !</admonition></text>

                <!-- CONFIG - LOG SECTION - LOG-LEVEL-FILE KEY -->
                <config-key-list>
                    <config-key id="log-level-file" name="Niveau du journal fichier">
                        <summary>Niveau d'enregistrement des traces lors de l'enregistrement sur fichier.</summary>

                        <text>Les niveaux de traces suivants sont pris en charge:
                        <ul>
                            <li><id>off</id> - Pas de journal de traces (non recommandé)</li>
                            <li><id>error</id> - Journaliser uniquement les erreurs</li>
                            <li><id>warn</id> - Journaliser les avertissements et les erreurs</li>
                            <li><id>info</id> - Journaliser les messages d'information, les avertissements et les erreurs</li>
                            <li><id>detail</id> - Journaliser les détails, les messages d'information, les avertissements et les erreurs</li>
                            <li><id>debug</id> - Journaliser les message de Débogage, les détails, les messages d'information, les avertissements et les erreurs</li>
                            <li><id>trace</id> - Journaliser les traces (un débogage très verbeux), les message de Débogage, les détails, les messages d'information, les avertissements et les erreurs</li>
                        </ul></text>

                        <example>debug</example>
                    </config-key>

                    <!-- CONFIG - LOG SECTION - LOG-LEVEL-CONSOLE KEY -->
                    <config-key id="log-level-console" name="Niveau du journal de la console">
                        <summary>Niveau de journalisation en sortie sur la console.</summary>

                        <text>Les niveaux de traces suivants sont pris en charge:
                        <ul>
                          <li><id>off</id> - Pas de journal de traces (non recommandé)</li>
                          <li><id>error</id> - Journaliser uniquement les erreurs</li>
                          <li><id>warn</id> - Journaliser les avertissements et les erreurs</li>
                          <li><id>info</id> - Journaliser les messages d'information, les avertissements et les erreurs</li>
                          <li><id>detail</id> - Journaliser les détails, les messages d'information, les avertissements et les erreurs</li>
                          <li><id>debug</id> - Journaliser les message de Débogage, les détails, les messages d'information, les avertissements et les erreurs</li>
                          <li><id>trace</id> - Journaliser les traces (un débogage très verbeux), les message de Débogage, les détails, les messages d'information, les avertissements et les erreurs</li>
                        </ul></text>

                        <example>error</example>
                    </config-key>

                    <!-- CONFIG - LOG SECTION - LOG-LEVEL-STDERR KEY -->
                    <config-key id="log-level-stderr" name="Niveau du journal pour stderr">
                        <summary>Niveau de traces sur la sortie console stderr.</summary>

                        <text>Spécifie les niveaux de traces qui sortiront en <id>stderr</id> plutôt que <id>stdout</id> (spécifié par <br-option>log-level-console</br-option>).  L'horodatage et le processus ne seront pas émis sur <id>stderr</id>.

                        Les niveaux de traces suivants sont pris en charge:
                        <ul>
                          <li><id>off</id> - Pas de journal de traces (non recommandé)</li>
                          <li><id>error</id> - Journaliser uniquement les erreurs</li>
                          <li><id>warn</id> - Journaliser les avertissements et les erreurs</li>
                          <li><id>info</id> - Journaliser les messages d'information, les avertissements et les erreurs</li>
                          <li><id>detail</id> - Journaliser les détails, les messages d'information, les avertissements et les erreurs</li>
                          <li><id>debug</id> - Journaliser les message de Débogage, les détails, les messages d'information, les avertissements et les erreurs</li>
                          <li><id>trace</id> - Journaliser les traces (un débogage très verbeux), les message de Débogage, les détails, les messages d'information, les avertissements et les erreurs</li>
                        </ul></text>

                        <example>error</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - LOG-PATH KEY -->
                    <config-key id="log-path" name="Emplacement du journal">
                        <summary>Emplacement où les fichiers journaux de traces sont stockés.</summary>

                        <text>Le chemin d'accès au journal fournit un emplacement pour <backrest/> pour stocker les fichiers journaux.  Notez que si <setting>log-level-file=off</setting> alors aucun chemin pour l'emplacement des journaux de traces n'est nécessaire.</text>

                        <example>/backup/db/log</example>
                    </config-key>

                    <!-- CONFIG - LOG SECTION - LOG-TIMESTAMP KEY -->
                    <config-key id="log-timestamp" name="Horodatage du journal">
                        <summary>Activer l'horodatage dans les traces.</summary>

                        <text>Active l'horodatage dans la console et l'enregistrement des fichiers.  Cette option est désactivée dans des situations particulières telles que la génération de documentation.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - LOG SECTION - LOG-SUBPROCESS KEY -->
                    <config-key id="log-subprocess" name="Journalisation des sous-processus">
                        <summary>Activer la journalisation des traces dans les sous-processus.</summary>

                        <text>Activez la journalisation des traces dans les fichiers pour tous les sous-processus créés par ce processus en utilisant le niveau de journalisation spécifié par <br-option>log-level-file</br-option>.</text>

                        <example>y</example>
                    </config-key>
                </config-key-list>
            </config-section>

            <!-- CONFIG - GENERAL -->
            <config-section id="general" name="General">
                <text>La section <setting>general</setting> définit les options qui sont communes à de nombreuses commandes.</text>

                <config-key-list>
                    <config-key id="buffer-size" name="Taille de la mémoire tampon">
                        <summary>Taille de la mémoire tampon pour les opérations sur les fichiers.</summary>

                        <text>Définissez la taille de la mémoire tampon utilisée pour les opérations de copie, de compression et de décompression.  Un maximum de 3 tampons seront utilisés à la fois par processus.  Un maximum supplémentaire de 256K par processus peut être utilisé pour les tampons zlib.

                        La taille peut être saisie en octets (par défaut) ou en KB, MB, GB, TB, ou PB où le multiplicateur est une puissance de 1024. Par exemple, la valeur insensible à la casse 32k (ou 32KB) peut être utilisée au lieu de 32768.

                        Les valeurs autorisées, en octets, sont<id>16384</id>, <id>32768</id>, <id>65536</id>, <id>131072</id>, <id>262144</id>, <id>524288</id>, <id>1048576</id>, <id>2097152</id>, <id>4194304</id>, <id>8388608</id>, et <id>16777216</id>.</text>

                        <example>32K</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - CMD-SSH KEY -->
                    <config-key id="cmd-ssh" name="Commande client SSH">
                        <summary>Chemin d'accès à l'exécutable du client ssh.</summary>

                        <text>Utilisez un client SSH spécifique lorsqu'une alternative est nécessaire ou lorsque l'exécutable <file>ssh</file> n'est pas dans $PATH.</text>

                        <example>/usr/bin/ssh</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - COMPRESS -->
                    <config-key id="compress" name="Compression">
                        <summary>Utilisez la compression de fichiers.</summary>

                        <text>Les fichiers de sauvegarde sont compatibles avec les outils de compression en ligne de commande.

                        Cette option est désormais obsolète. L'option <setting>compress-type</setting> doit être utilisée à la place.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - COMPRESS-TYPE -->
                    <config-key id="compress-type" name="Type de compression">
                        <summary>Type de compression pour les fichiers.</summary>

                        <text>Les types de compression suivants sont pris en charge :
                        <ul>
                            <li><id>bz2</id> - format de compression bzip2</li>
                            <li><id>gz</id> - format de compression gzip</li>
                            <li><id>lz4</id> - format de compression lz4 (non disponible sur toutes les plateformes)</li>
                            <li><id>zst</id> - format de compression Zstandard (non disponible sur toutes les plateformes)</li>
                        </ul></text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - COMPRESS-LEVEL KEY -->
                    <config-key id="compress-level" name="Niveau de compression">
                        <summary>Niveau de compression des fichiers.</summary>

                        <text>Définit le niveau à utiliser pour la compression des fichiers lorsque <setting>compress-type</setting> n'est pas égal à <id>none</id> ou <setting>compress=y</setting> (déprécié).</text>

                        <allow>0-9</allow>
                        <example>9</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - COMPRESS-LEVEL-NETWORK KEY -->
                    <config-key id="compress-level-network" name="Niveau de compression réseau">
                        <summary>Niveau de compression du réseau.</summary>

                        <text>Définit le niveau de compression sur le réseau, lorsque <setting>compress-type=none</setting> et que la commande n'est pas exécutée sur le même hôte que le dépôt.  La compression est utilisée pour réduire le trafic réseau mais peut être désactivée en définissant <setting>compress-level-network=0</setting>.  Lorsque <setting>compress-type</setting> n'est pas égal à <id>none</id>, le paramètre <setting>compress-level-network</setting> est ignoré et <setting>compress-level</setting> est utilisé à la place de sorte que le fichier ne soit compressé qu'une seule fois.  La compression SSH est toujours désactivée.</text>

                        <allow>0-9</allow>
                        <example>1</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - DB-TIMEOUT KEY -->
                    <config-key id="db-timeout" name="Timeout de la base de données">
                        <summary>Délai d'attente des requêtes à la base de données.</summary>

                        <text>Définit le délai d'attente, en secondes, pour les interrogations de la base de données.  Cela inclut les fonctions <code>pg_start_backup()</code> et <code>pg_stop_backup()</code> qui peuvent chacune prendre un temps considérable.  C'est pourquoi le délai d'attente doit être maintenu à un niveau élevé, sauf si vous savez que ces fonctions retourneront rapidement (c'est-à-dire si vous avez défini <setting>startfast=y</setting> et que vous savez que l'instance de base de données ne générera pas beaucoup de segments WAL pendant la sauvegarde). <admonition type="note">L'option <br-option>db-timeout</br-option> doit être inférieure à l'option <br-option>protocol-timeout</br-option>.</admonition></text>

                        <example>600</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - DELTA OPTION -->
                    <config-key id="delta" name="Delta">
                        <summary>Restauration ou sauvegarde à l'aide de sommes de contrôle.</summary>

                        <text>Lors d'une restauration, par défaut, les répertoires <postgres/> data et tablespace sont censés être présents mais vides.  Cette option effectue une restauration delta en utilisant des sommes de contrôle.

                        Lors d'une sauvegarde, cette option utilisera les sommes de contrôle au lieu des horodatages pour déterminer si les fichiers devront être copiés.</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - IO-TIMEOUT KEY -->
                    <config-key id="io-timeout" name="Délai d'attente E/S">
                        <summary>Délai d'attente E/S.</summary>

                        <text>Délai d'attente, en secondes, utilisé pour les connexions et les opérations de lecture/écriture.

                        Notez que l'ensemble de l'opération de lecture/écriture n'a pas besoin de se terminer dans ce délai mais une <i>progression</i> doit être constatée, même s'il ne s'agit que d'un seul octet.</text>

                        <example>120</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - LOCK-PATH KEY -->
                    <config-key id="lock-path" name="Chemin fichier de verrouillage">
                        <summary>Chemin d'accès où sont stockés les fichiers de verrouillage.</summary>

                        <text>Le chemin de verrouillage fournit l'emplacement à <backrest/> pour créer des fichiers de verrouillage afin d'éviter que des opérations en conflictuelles ne soient exécutées simultanément.</text>

                        <example>/backup/db/lock</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - NEUTRAL-UMASK -->
                    <config-key id="neutral-umask" name="Umask neutre">
                        <summary>Utilisation d'un <quote>umask</quote> neutre</summary>

                        <text>Définit l'umask à 0000 pour que les modes dans le dépôt de sauvegarde soient créés de manière appropriée.  Le mode par défaut du répertoire est 0750 et le mode par défaut du fichier est 0640.  Pour les répertoires lock et log, les modes de répertoire et de fichier sont respectivement fixés à 0770 et 0660.

                        Pour utiliser l'umask de l'utilisateur en cours d'exécution, spécifiez plutôt <setting>neutral-umask=n</setting> dans le fichier de configuration ou <setting>--no-neutral-umask</setting> sur la ligne de commande.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - LOG-PATH KEY -->
                    <config-key id="spool-path" name="Chemin pour données transitoires (Spool)">
                        <summary>Chemin où les données transitoires sont stockées.</summary>

                        <text>Ce chemin est utilisé pour stocker les données nécessaires à la commande asynchrone <cmd>archive-push</cmd> et <cmd>archive-get</cmd>.

                        La commande asynchrone <cmd>archive-push</cmd> enregistre des accusés de réception dans le chemin du spool lorsqu'elle a stocké avec succès le WAL dans l'archive (et des erreurs en cas d'échec) afin que le processus de premier plan puisse rapidement notifier <postgres/>. Les fichiers d'accusés de réception sont très petits (zéro octets en cas de succès et quelques centaines d'octets en cas d'erreur).

                        La commande asynchrone <cmd>archive-get</cmd> met en file d'attente le WAL dans le chemin du spool afin qu'il puisse être fourni très rapidement lorsque <postgres/> le demande.  Le déplacement de fichiers vers <postgres/> est plus efficace lorsque le chemin du spool se trouve sur le même système de fichiers que <path>pg_xlog</path>/<path>pg_wal</path>.

                        Les données stockées dans le chemin du spool ne sont pas réellement temporaires puisqu'elles peuvent et doivent survivre à un redémarrage.  Cependant, la perte des données dans le chemin du spool n'est pas un problème.  <backrest/> va simplement revérifier chaque segment WAL pour s'assurer qu'il est bien archivé pour <cmd>archive-push</cmd> et reconstruire la file d'attente pour <cmd>archive-get</cmd>.

                        Le chemin du spool est destiné à être situé sur un système de fichiers local compatible Posix, et non sur un système de fichiers distant tel que <proper>NFS</proper> ou <proper>CIFS</proper>.</text>

                        <example>/backup/db/spool</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - PROCESS-MAX -->
                    <config-key id="process-max" name="Processus Maximum">
                        <summary>Nombre de processus maximal lors utilisé lors de la compression et du transfert.</summary>

                        <text>Chaque processus effectuera une compression et un transfert pour que la commande s'exécute plus rapidement, mais ne réglez pas <setting>process-max</setting> à un niveau si élevé que cela affecte les performances de la base de données.</text>

                        <example>4</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - PROTOCOL-TIMEOUT KEY -->
                    <config-key id="protocol-timeout" name="Délai d'attente au niveau Protocole">
                        <summary>Délai d'attente du protocole.</summary>

                        <text>Définit le délai, en secondes, durant lequel le processus local ou distant attendra qu'un nouveau message soit reçu au niveau de la couche protocole.  Cela permet d'éviter que les processus n'attendent indéfiniment un message. <admonition type="note">L'option <br-option>protocol-timeout</br-option> doit être supérieure à celle de <br-option>db-timeout</br-option> option.</admonition></text>

                        <example>630</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - SCK-KEEP-ALIVE KEY -->
                    <config-key id="sck-keep-alive" name="Keep Alive">
                        <summary>Activation de la fonction de keep-alive (maintien en vie).</summary>

                        <text>Activation des messages de keep-alive (maintien en vie) sur les connexions réseaux.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - TCP-KEEP-ALIVE-COUNT KEY -->
                    <config-key id="tcp-keep-alive-count" name="Conteur Keep Alive">
                        <summary>Compteur Keep-alive.</summary>

                        <text>Spécifie le nombre de messages TCP à garder en mémoire qui peuvent être perdus avant que la connexion ne soit considérée comme morte.

                        Cette option n'est disponible que sur les systèmes qui prennent en charge l'option réseau <code>TCP_KEEPCNT</code>.</text>

                        <example>3</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - TCP-KEEP-ALIVE-IDLE KEY -->
                    <config-key id="tcp-keep-alive-idle" name="Temps d'inactivité Keep Alive">
                        <summary>Temps d'inactivité du keepalive.</summary>

                        <text>Spécifie la durée (en secondes) sans activité du réseau après laquelle le système d'exploitation doit envoyer un message TCP de maintien en activité (keep-alive).

                        Cette option n'est disponible que sur les systèmes qui prennent en charge l'option réseau <code>TCP_KEEPIDLE</code>.</text>

                        <example>60</example>
                    </config-key>

                    <!-- CONFIG - GENERAL SECTION - TCP-KEEP-ALIVE-INTERVAL KEY -->
                    <config-key id="tcp-keep-alive-interval" name="Intervalle du Keep Alive">
                        <summary>Temps d'intervalle de maintien en vie (keep-alive).</summary>

                        <text>Spécifie le temps (en secondes) après lequel un message TCP de maintien en activité (keep-alive) non acquitté doit être retransmis.

                        Cette option n'est disponible que sur les systèmes qui prennent en charge l'option réseau <code>TCP_KEEPINTVL</code>.</text>

                        <example>30</example>
                    </config-key>
                </config-key-list>
            </config-section>

            <!-- CONFIG - REPO -->
            <config-section id="repository" name="Dépot (Repository)">
                <text>La section <setting>repository</setting> (dépot) définit les options utilisées pour configurer le dépôt de sauvegarde.

                <b>Indexation</b> : Toutes les options <setting>repo-</setting> sont indexées pour permettre la configuration de plusieurs dépôts, bien qu'un seul dépôt soit actuellement pris en charge. Par exemple, le dépôt est configuré avec les options <setting>repo1-path</setting>, <setting>repo1-host</setting>, etc.

                Les options <setting>repo-retention-*</setting> définissent la durée de la rétention des sauvegardes.  L'expiration ne se produit que lorsque le nombre de sauvegardes complètes dépasse la rétention autorisée.  Autrement dit, si l'option de conservation-full est réglée sur 2, il doit y avoir 3 sauvegardes complètes avant que la plus ancienne ne soit périmée.  Veillez à toujours disposer d'un espace suffisant pour la conservation + 1 sauvegarde.</text>

                <config-key-list>
                    <!-- CONFIG - REPO SECTION - REPO-HOST KEY -->
                    <config-key id="repo-host" name="Hôte du dépot">
                        <summary>Hôte de dépôt dans le cas d'un fonctionnement à distance via SSH.</summary>

                        <text>Assurez-vous que l'authentification SSH soit correctement approuvé entre l'hôte <postgres/> et l'hôte du référentiel.

                        Ce paramètre n'est pas nécessaire pour la sauvegarde et l'archivage sur un système de fichiers monté localement.</text>

                        <example>repo1.domain.com</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HOST-CMD KEY -->
                    <config-key id="repo-host-cmd" name="Repository Host Command">
                        <summary>Chemin des binaires <backrest/> sur l'hôte du dépôt.</summary>

                        <text>Nécessaire uniquement si le chemin d'accès à <exe/> est différent entre les hôtes locaux et l'hote du dépôt.  S'il n'est pas défini, le chemin des binaires sur l'hôte du dépôt sera le même que le chemin des binaires locaux.</text>

                        <default>identique au local</default>
                        <example>/usr/lib/backrest/bin/pgbackrest</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HOST-CONFIG KEY -->
                    <config-key id="repo-host-config" name="Repository Host Configuration">
                        <summary>Emplacement du fichier de configuration <backrest/> sur l'hôte du dépôt.</summary>

                        <text>Définit l'emplacement du fichier de configuration sur l'hôte du dépôt.  Ceci n'est nécessaire que si le fichier de configuration de l'hôte du dépôt se trouve dans un emplacement différent de celui du fichier de configuration local.</text>

                        <example>/conf/pgbackrest/pgbackrest.conf</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HOST-CONFIG-INCLUDE-PATH KEY -->
                    <config-key id="repo-host-config-include-path" name="Repository Host Configuration Include Path">
                        <summary>Chemin d'inclusion <backrest/>  de la configuration de l'hôte du dépôt.</summary>

                        <text>Définit l'emplacement du chemin d'inclusion de la configuration sur l'hôte du dépôt.  Ceci n'est nécessaire que si le chemin d'inclusion de la configuration de l'hôte du dépôt se trouve à un endroit différent du chemin d'inclusion de la configuration locale.</text>

                        <example>/conf/pgbackrest/conf.d</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HOST-CONFIG-PATH KEY -->
                    <config-key id="repo-host-config-path" name="Repository Host Configuration Path">
                        <summary>Chemin de configuration <backrest/> de l'hôte du dépôt.</summary>

                        <text>Définit l'emplacement du chemin de configuration sur l'hôte du dépôt.  Ceci n'est nécessaire que si le chemin de configuration de l'hôte du référentiel se trouve à un endroit différent du chemin de configuration local.</text>

                        <example>/conf/pgbackrest</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HOST-USER KEY -->
                    <config-key id="repo-host-user" name="Repository Host User">
                        <summary>Utilisateur de l'hôte du dépôt lorsque <setting>repo-host</setting> est défini.</summary>

                        <text>Définit l'utilisateur qui sera utilisé pour les opérations sur l'hôte du dépôt.  De préférence, il ne s'agit pas de l'utilisateur <id>postgres</id> mais plutôt d'un autre utilisateur comme <id>pgbackrest</id>.  Si <postgres/> fonctionne sur l'hôte du dépôt, l'utilisateur <id>postgres</id> peut être placé dans le groupe <id>pgbackrest</id> afin qu'il ait les autorisations de lecture sur le dépôt sans pouvoir en endommager le contenu accidentellement.</text>

                        <example>repo-user</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HOST-PORT KEY -->
                    <config-key id="repo-host-port" name="Repository Host Port">
                        <summary>Port de l'hôte du dépôt lorsque <setting>repo-host</setting> est défini.</summary>

                        <text>Utilisez cette option pour spécifier un port non par défaut pour le protocole d'accès à l'hôte du dépôt.  Actuellement, seul SSH est pris en charge</text>

                        <example>25</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-HARDLINK -->
                    <config-key id="repo-hardlink" name="Repository Hardlink">
                        <summary>Liens physiques (hardlink) des fichiers entre les sauvegardes dans le dépôt.</summary>

                        <text>Activation la liaison physique des fichiers dans les sauvegardes différentielles et incrémentales avec leurs sauvegardes complètes.  Cela donne l'impression que chaque sauvegarde est une sauvegarde complète au niveau du système de fichiers.  Attention, cependant, car la modification de fichiers liés peut affecter toutes les sauvegardes de ce jeu.</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-PATH KEY -->
                    <config-key id="repo-path" name="Repository Path">
                        <summary>Chemin d'accès où sont stockées les sauvegardes et les archives.</summary>

                        <text>Le dépôt est l'endroit où <backrest/> stocke les sauvegardes et archive les segments des journaux de transaction (WAL).

                        Il peut être difficile d'estimer à l'avance l'espace dont vous aurez besoin.  La meilleure chose à faire est de prendre quelques sauvegardes puis d'enregistrer la taille des différents types de sauvegardes (full/incr/diff) et de mesurer la quantité de WAL générée par jour.  Cela vous donnera une idée générale de l'espace dont vous aurez besoin, même si, bien sûr, les besoins changeront probablement au fil du temps, à fur et à mesure de l'évolution de votre base de données.</text>

                        <example>/backup/db/backrest</example>
                    </config-key>

                    <!-- CONFIG - RETENTION SECTION - REPO-RETENTION-FULL KEY -->
                    <config-key id="repo-retention-full" name="Full Retention">
                        <summary>Nombre ou temps de sauvegardes complètes à conserver.</summary>

                        <text>Lorsqu'une sauvegarde complète expire, toutes les sauvegardes différentielles et incrémentielles associées à la sauvegarde complète expirent également.  Lorsque l'option n'est pas définie, un avertissement sera émis.  Si une conservation indéfinie est souhaitée, il faut alors définir l'option à la valeur maximale.</text>

                        <example>2</example>
                    </config-key>

                    <!-- CONFIG - RETENTION SECTION - REPO-RETENTION-FULL-TYPE KEY -->
                    <config-key id="repo-retention-full-type" name="Full Retention Type">
                        <summary>Type de conservation pour les sauvegardes complètes.</summary>

                        <text>Détermine si le paramètre <setting>repo-retention-full</setting> représente une période de temps (jours) ou le nombre de sauvegardes complètes à conserver. Si le paramètre est réglé sur <setting>time</setting> les sauvegardes complètes plus anciennes que le paramètre <setting>repo-retention-full</setting> seront supprimées du dépôt si au moins une sauvegarde est égale ou supérieure au paramètre <setting>repo-retention-full</setting>. Par exemple, si <setting>repo-retention-full</setting> est de 30 (jours) et qu'il y a 2 sauvegardes complètes : une de 25 jours et une de 35 jours, aucune sauvegarde complète n'expirera puisque l'expiration de la sauvegarde de 35 jours ne laisserait que la sauvegarde de 25 jours; ce qui violerait la politique de conservation de 30 jours : à savoir, avoir au moins une sauvegarde de 30 jours avant qu'une plus ancienne puisse expirer. Les journaux de transactions archivés (WAL) plus anciennes que la sauvegarde complète la plus ancienne restante seront automatiquement expirées, à moins que les paramètres <setting>repo-retention-archive-type</setting> et <setting>repo-retention-archive</setting> ne soient explicitement définis.</text>

                        <example>30</example>
                    </config-key>

                    <!-- CONFIG - RETENTION SECTION - REPO-DIFFERENTIAL-RETENTION KEY -->
                    <config-key id="repo-retention-diff" name="Differential Retention">
                        <summary>Nombre de sauvegardes différentielles à conserver.</summary>

                        <text>Lorsqu'une sauvegarde différentielle expire, toutes les sauvegardes incrémentales associées à la sauvegarde différentielle expirent également.  Lorsqu'elles ne sont pas définies, toutes les sauvegardes différentielles seront conservées jusqu'à ce que les sauvegardes complètes dont elles dépendent expirent.</text>

                        <example>3</example>
                    </config-key>

                    <!-- CONFIG - RETENTION SECTION - REPO-ARCHIVE-RETENTION-TYPE KEY -->
                    <config-key id="repo-retention-archive-type" name="Archive Retention Type">
                        <summary>Type de sauvegarde pour la conservation des journaux de transaction (WAL).</summary>

                        <text>Lorsque <setting>repo-retention-archive-type</setting> est positionné sur <setting>full</setting> <backrest/> conservera les journaux de trasnaction (WAL) pour le nombre de sauvegardes complètes défini par <setting>repo-retention-archive</setting>.  S'il est positionné sur  <setting>diff</setting> (différentiel) <backrest/> conservera les journaux de trasnaction (WAL) pour le nombre de sauvegardes complètes et différentielles défini par <setting>repo-retention-archive</setting>, ce qui signifie que si la dernière sauvegarde effectuée était une sauvegarde complète, elle sera comptée comme un différentiel pour les besoins de la retention du dépôt.  S'il est positionné sur <setting>incr</setting> (incrémental) <backrest/> conservera les journaux de trasnaction (WAL) pour le nombre de sauvegardes complètes, différentielles et incrémentielles défini par <setting>repo-retention-archive</setting>. Il est recommandé de ne pas modifier ce paramètre par rapport à la valeur par défaut : expiration que lorsque les sauvegardes complètes auront expiré.</text>

                        <example>diff</example>
                    </config-key>

                    <!-- CONFIG - RETENTION SECTION - REPO-ARCHIVE-RETENTION KEY -->
                    <config-key id="repo-retention-archive" name="Rétention d'Archive ">
                        <summary>Nombre de sauvegardes correspondant à la valeur de WAL continue à conserver.</summary>

                        <text><admonition type="note">Les segments WAL nécessaires pour rendre une sauvegarde cohérente sont toujours conservés jusqu'à l'expiration de la sauvegarde, quelle que soit la configuration de cette option.</admonition> Si cette configuration n'est pas définie et que <setting>repo-retention-full-type</setting> est positionné sur <setting>count</setting> (valeur par défaut), alors l'expiration de l'archive sera par défaut à la valeur de <setting>repo-retention-full</setting>  si <setting>repo-retention-archive-type</setting> est définit à <setting>full</setting> (ou à <setting>repo-retention-diff</setting> si <setting>repo-retention-archive-type</setting> est définit à <setting>diff</setting> ). Cela permet de garantir que le WAL n'expirera que pour les sauvegardes ayant déjà expirées. Si <setting>repo-retention-full-type</setting> est positionné sur <setting>time</setting>, avec cette valeur, par défaut, les archives qui sont antérieures à la plus ancienne sauvegarde complète conservée et satisfaisant au paramètre <setting>repo-retention-full</setting> seront supprimés.

                        Cette option doit être définie si <setting>repo-retention-archive-type</setting> est positionné sur <setting>incr</setting>. Si l'espace disque est insuffisant, ce paramètre, associé à <setting>repo-retention-archive-type</setting>, peut être utilisé pour faire expirer de manière agressive les segments WAL. Toutefois, cela annule la possibilité d'effectuer un PITR à partir des sauvegardes avec les WAL expirés et donc <b>n'est pas</b> recommandé.</text>

                        <example>2</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-KEY KEY -->
                    <config-key id="repo-s3-key" name="Clé d'accès S3">
                        <summary>Clé d'accès au dépôt S3.</summary>

                        <text>Clé AWS utilisée pour accéder au bucket.</text>

                        <example>AKIAIOSFODNN7EXAMPLE</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-KEY-SECRET KEY -->
                    <config-key id="repo-s3-key-secret" name="Clé d'accès secrète S3">
                        <summary>Clé d'accès secrète au dépôt S3.</summary>

                        <text>Clé secrète AWS utilisée pour accéder au bucket.</text>

                        <example>wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-TOKEN KEY -->
                    <config-key id="repo-s3-token" name="Jeton de sécurité pour le dépôt S3">
                        <summary>Jeton de sécurité pour le dépôt S3.</summary>

                        <text>Jeton de sécurité AWS utilisé avec des identifiants temporaires.</text>

                        <example>AQoDYXdzEPT//////////wEXAMPLEtc764bNrC9SAPBSM22 ...</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-BUCKET KEY -->
                    <config-key id="repo-s3-bucket" name="S3 Bucket">
                        <summary>S3 dépôt bucket.</summary>

                        <text>Bucket S3 utilisé pour stocker le dépôt.

                        Les dépots <backrest/> peuvent être stockés à la racine du bucket en définissant <br-option>repo-path=/</br-option> mais il est généralement préférable de spécifier un préfixe, comme par exemple <path>/repo</path>, afin que les logs et autres contenus générés par AWS puissent également être stockés dans le bucket.</text>

                        <example>pg-backup</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-CA-FILE KEY -->
                    <config-key id="repo-s3-ca-file" name="Fichier SSL CA S3">
                        <summary>Ficher SSL CA S3.</summary>

                        <text>Utiliser un fichier CA autre que celui défini par défaut dans le système.</text>

                        <example>/etc/pki/tls/certs/ca-bundle.crt</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-CA-PATH KEY -->
                    <config-key id="repo-s3-ca-path" name="Chemin SSL CA">
                        <summary>Chemin S3 SSL CA.</summary>

                        <text>Utiliser un chemin pour le CA autre que celui défini par défaut dans le système.</text>

                        <example>/etc/pki/tls/certs</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-ENDPOINT KEY -->
                    <config-key id="repo-s3-endpoint" name="Point de terminaison S3">
                        <summary>Dépot S3 Point de terminaison (endpoint).</summary>

                        <text>Le point de terminaison d'AWS doit être valable pour la région sélectionnée.</text>

                        <example>s3.amazonaws.com</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-HOST KEY -->
                    <config-key id="repo-s3-host" name="Hôte S3">
                        <summary>Hôte du dépot S3.</summary>

                        <text>Conntecter sur un hôte différent du point de terminaison (endpoint). Il est généralement utilisé à des fins de test.</text>

                        <example>127.0.0.1</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-PORT KEY -->
                    <config-key id="repo-s3-port" name="Port S3">
                        <summary>Port de connection au dépot S3.</summary>

                        <text>Port à utiliser lors de la connexion au point de terminaison (ou à l'hôte si spécifié).</text>

                        <example>9000</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-REGION KEY -->
                    <config-key id="repo-s3-region" name="Région S3">
                        <summary>Région du dépôt S3.</summary>

                        <text>La région d'AWS où le bucket a été créé.</text>

                        <example>us-east-1</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-URI-STYLE KEY -->
                    <config-key id="repo-s3-uri-style" name="S3 Formats d'URI">
                        <summary>S3 URI formats.</summary>

                        <text>Les formats URI suivants sont pris en charge:
                        <ul>
                            <li><id>host</id> - Connexion à l'hôte <id>bucket.endpoint</id>.</li>
                            <li><id>path</id> - Connexion à l'hôte <id>endpoint</id> et ajout du bucket aux URIs.</li>
                        </ul></text>

                        <example>path</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-S3-VERIFY-TLS KEY -->
                    <config-key id="repo-s3-verify-tls" name="S3 Vérifiction TLS">
                        <summary>Vérifier le certificat du serveur S3.</summary>

                        <text>Désactive la vérification du certificat du serveur S3. Cette fonction ne doit être utilisée que dans le cadre de tests ou dans le cas d'une utilisation avec un certificat a été auto-signé.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-TYPE KEY -->
                    <config-key id="repo-type" name="Type de dépot">
                        <summary>Type de stockage utilisé pour le dépôt.</summary>

                        <text>Les types de stockage suivants sont pris en charge :
                        <ul>
                            <li><id>cifs</id> - Comme <id>posix</id>, mais désactive les liens et les fsyncs sur les répertoires</li>
                            <li><id>posix</id> - Systèmes de fichiers conformes à Posix</li>
                            <li><id>s3</id> - Service de stockage d'objet (AWS Simple Storage Service)</li>
                        </ul></text>

                        <example>cifs</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-CIPHER-TYPE KEY -->
                    <config-key id="repo-cipher-type" name="Type de chiffrement du dépôt">
                        <summary>Chiffrement (cipher) utilisé pour chiffrer le dépôt.</summary>

                        <text>Les types de chiffrement suivants sont pris en charge:
                        <ul>
                            <li><id>none</id> - Le dépôt n'est pas chiffré.</li>
                            <li><id>aes-256-cbc</id> - Advanced Encryption Standard avec une clef de 256 bit</li>
                        </ul>À noter que le chiffrement est toujours effectué côté client même si le type de stockage (par exemple S3) supporte le chiffrement.</text>

                        <default>none</default>
                        <example>aes-256-cbc</example>
                    </config-key>

                    <!-- CONFIG - REPO SECTION - REPO-CIPHER-PASS KEY -->
                    <config-key id="repo-cipher-pass" name="Phrase de chiffrement du dépôt">
                        <summary>Phrase de chiffrement du dépôt.</summary>

                        <text>Mot de passe utilisée pour chiffrer/déchiffrer les fichiers du dépôt.</text>

                        <example>zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO</example>
                    </config-key>
                </config-key-list>
            </config-section>

            <!-- CONFIG - BACKUP -->
            <config-section id="backup" name="Sauvegarde">
                <text>La section <setting>backup</setting> définit les paramètres relatifs à la sauvegarde.</text>

                <config-key-list>
                    <!-- CONFIG - BACKUP SECTION - ARCHIVE-CHECK -->
                    <config-key id="archive-check" name="Check Archive">
                        <summary>Contrôle que les segments WAL se trouvent bien dans les archives à la fin du processus de sauvegarde.</summary>

                        <text>Contrôle que tous les segments de WAL nécessaires pour rendre la sauvegarde cohérente sont présents dans les archives de WAL.  Il est conseillé de laisser ce paramètre par défaut, à moins que vous n'utilisiez une autre méthode d'archivage..

                        Cette option doit être activée si <br-option>archive-copy</br-option> est activé.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - ARCHIVE-COPY -->
                    <config-key id="archive-copy" name="Copie des Archives">
                        <summary>Copier tous les segments WAL nécessaires à la cohérence de la sauvegarde.</summary>

                        <text>Cette option un peu parano protège contre la corruption dans les archives des segments WAL en stockant les segments WAL nécessaires à la cohérence directement dans la sauvegarde. Les segments WAL sont toujours stockés dans l'archive, donc cette option utilisera de l'espace supplémentaire.

                        Lors de la restauration, les segments WAL seront présents dans <path>pg_xlog/pg_wal</path> et <postgres/> les utilisera de préférence plutôt que d'appeler la <code>restore_command</code>.

                        L'option <br-option>archive-check</br-option> doit être activée si <br-option>archive-copy</br-option> est activée</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - BACKUP-STANDBY KEY -->
                    <config-key id="backup-standby" name="Sauvegarde à partir du secondaire">
                        <summary>Sauvegarde depuis l'instance standby secondaire.</summary>

                        <text>Activer la sauvegarde depuis le secondaire en standby pour réduire la charge sur l'instance primaire. Cette option nécessite que les hôtes <host>primary</host> (primaire) et <host>standby</host> (secondaire en standby) soit correctement configurés.</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - CHECKSUM-PAGE KEY -->
                    <config-key id="checksum-page" name="Sommes de controle des Pages">
                        <summary>Validation des sommes de contrôle des pages de données (checksums).</summary>

                        <text>Permet à <backrest/> de valider toutes les sommes de contrôle des pages de données pendant la sauvegarde de l'instance.  Cette option est automatiquement activée lorsque les sommes de contrôle des pages de données sont activées sur l'instance.

                        Un échec dans la validation de la somme de contrôle n'annulera pas la sauvegarde.  Au contraire, des avertissements seront émis dans le journal des traces (et par défaut sur la console); la liste des pages non valides sera stockée dans le manifeste de sauvegarde.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - EXCLUDE KEY -->
                    <config-key id="exclude" name="Exclusions Chemin/Fichier">
                        <summary>Exclusion des chemins/fichiers de la sauvegarde..</summary>

                        <text>Toutes les exclusions sont relatives à <path>$PGDATA</path>. Si l'exclusion se termine par / alors seuls les fichiers du répertoire spécifié seront exclus, par exemple <br-option>--exclude=junk/</br-option> exclura tous les fichiers du répertoire <path>$PGDATA/junk</path> mais inclura le répertoire lui-même.  Si l'exclusion ne se termine pas par / alors le fichier peut correspondre exactement à l'exclusion ou correspondre à / apposé à l'exclusion, par exemple <br-option>--exclude=junk</br-option> exclura le répertoire <path>$PGDATA/junk</path> et tous les fichiers qu'il contient.

                        <b>Soyez prudent en utilisant cette fonctionnalité : il est très rapide d'exclure quelque chose d'essentiel qui rendra la sauvegarde incohérente.  Assurez-vous de tester vos restaurations ! </b>

                        Tous les fichiers exclus seront journalisés au niveau <id>info</id> avec la règle d'exclusion.Veillez à vérifier la liste des fichiers exclus pour vous assurer que rien d'inattendu n'est exclu.<admonition type="note">Les exclusions ne sont pas prises en compte lors des restaurations delta.  Tout fichier/répertoire qui a été exclu par la sauvegarde sera <i>supprimé</i> lors de la restauration delta.</admonition>Cette option ne doit pas être utilisée pour exclure les journaux de traces <postgres/> d'une sauvegarde.  Les journaux peuvent être déplacés hors du répertoire <id>PGDATA</id> en utilisant le paramètre <postgres/> <setting>log_directory</setting>, ce qui présente l'avantage de permettre la préservation des journaux après une restauration.

                        Les exclusions multiples peuvent être spécifiées sur la ligne de commande ou dans le fichier de configuration.</text>

                        <example>junk/</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - MANIFEST-SAVE-THRESHOLD -->
                    <config-key id="manifest-save-threshold" name="Seuil sauvegarde manifeste">
                        <summary>Seuil de déclenchement de la sauvegarde du manifeste lors de la sauvegarde.</summary>

                        <text>Définit la fréquence à laquelle le manifeste sera sauvegardé lors d'une sauvegarde.  La sauvegarde du manifeste est importante car elle permet de stocker les sommes de contrôle et de faire fonctionner efficacement la fonction de reprise.  Le volume réel utilisé est de 1 % de la taille de la sauvegarde ou <setting>manifest-save-threshold</setting>, la valeur la plus élevée étant retenue.

                        La taille peut être saisie en octets (par défaut) ou en KB, MB, GB, TB, ou PB où le multiplicateur est une puissance de 1024.</text>

                        <example>5G</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - RESUME -->
                    <config-key id="resume" name="Reprise">
                        <summary>Permettre la reprise d'une sauvegarde échoué</summary>

                        <text>Définit si la fonctionnalité de reprise est activée.  La reprise peut réduire considérablement le temps nécessaire pour exécuter une sauvegarde si une sauvegarde précédente du même type a échoué.  Elle ajoute toutefois de la complexité, de sorte qu'il peut être conseillé de la désactiver dans les environnements qui n'ont pas besoin de cette fonction.</text>

                        <example>n</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - START-FAST -->
                    <config-key id="start-fast" name="Démarrage rapide">
                        <summary>Forcer un point de contrôle (checkpoint) pour lancer plus rapidement la sauvegarde.</summary>

                        <text>Force un point de contrôle (en passant le paramètre <id>y</id> à <id>fast</id> de <code>pg_start_backup()</code>) pour que la sauvegarde commence immédiatement.  Sinon, la sauvegarde commencera après le prochain point de contrôle contrôle.

                        Cette fonction ne fonctionne qu'à partir de <postgres/> version &gt;= <id>8.4</id>.</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - BACKUP SECTION - STOP-AUTO -->
                    <config-key id="stop-auto" name="Arrêt Automatique">
                        <summary>Arrêt d'une sauvegarde antérieure défaillante lors la nouvelle sauvegarde.</summary>

                        <text>Cette opération ne sera effectuée que si un verrouillage consultatif exclusif peut être acquis afin de faire la preuve que le processus de sauvegarde antérieur ayant échoué s'est réellement arrêté.

                        Cette fonctionnalité repose sur pg_is_in_backup() et ne fonctionne donc qu'avec <postgres/> >= <id>9.3</id>.

                        Cette fonctionnalité n'est pas prise en charge pour <postgres/> >= <id>9.6</id> car les sauvegardes sont exécutées en mode non exclusif.

                        Ce paramètre est désactivé par défaut car il suppose que <backrest/> est le seul processus qui effectue exclusivement des sauvegardes en ligne.  Il se base sur un verrou consultatif que seul <backrest/> définit afin de pouvoir interrompre les autres processus qui effectuent des sauvegardes exclusives en ligne.  Notez que <cmd>base_backup</cmd> et <cmd>pg_dump</cmd> sont sans risque avec ce paramétrage car ils n'appellent pas <code>pg_start_backup()</code> et ne sont donc pas exclusifs.</text>

                        <example>y</example>
                    </config-key>
                </config-key-list>
            </config-section>

            <!-- CONFIG - ARCHIVE -->
            <config-section id="archive" name="Archive">
                <text>La section <setting>archive</setting> définit les options des commandes <cmd>archive-push</cmd> et <cmd>archive-get</cmd>.</text>

                <config-key-list>
                    <!-- CONFIG - ARCHIVE SECTION - ARCHIVE-ASYNC KEY -->
                    <config-key id="archive-async" name="Archivage asynchrone">
                        <summary>Pousser et obtenir des segments WAL de manière asynchrone.</summary>

                        <text>Permet d'activer un fonctionnement asynchrone pour les commandes <cmd>archive-push</cmd> et <cmd>archive-get</cmd>.

                        Le fonctionnement asynchrone est plus performant car il permet de réutiliser les connexions et de tirer parti du parallélisme.  Consultez les options <br-option>spool-path</br-option>, <br-option>archive-get-queue-max</br-option>, et <br-option>archive-push-queue-max</br-option> pour plus d'informations.</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - ARCHIVE SECTION - ARCHIVE-GET-QUEUE-MAX KEY -->
                    <config-key id="archive-get-queue-max" name="Taille maximale file d'attente récupération d'Archive">
                        <summary>Taille maximale de la file d'attente <backrest/> archive-get.</summary>

                        <text>Spécifie la taille maximale de la file d'attente <cmd>archive-get</cmd> lorsque <br-option>archive-async</br-option> est activée.  La file d'attente est stockée sur l'emplacement définit par <br-option>spool-path</br-option> et est utilisée pour accélérer la réception des données de WAL par <postgres/>.

                        La taille peut être saisie en octets (par défaut) ou en KB, MB, GB, TB ou PB où le multiplicateur est une puissance de 1024.</text>

                        <example>1073741824</example>
                    </config-key>

                    <!-- CONFIG - ARCHIVE SECTION - ARCHIVE-QUEUE-MAX KEY -->
                    <config-key id="archive-push-queue-max" name="Taille maximale de la file d'attente pour les archives">
                        <summary>Taille maximale de la file d'attente <postgres/> archive..</summary>

                        <text>Une fois la limite atteinte, voici ce qui se produira :
                        <ol>
                            <li><backrest/> signalera à <postgres/> que les journaux de transaction (WAL) ont été archivée avec succès, puis, <b>LES SUPPRIMES</b>.</li>
                            <li>Un avertissement sera émis dans le journal de trace de <postgres/>.</li>

                        </ol>Si cela se produit, le flux d'archives sera interrompu et le PITR ne sera plus possible au-delà de ce moment.  Une nouvelle sauvegarde est alors indispensable pour retrouver la fonctionnalité de restauration complète.

                        En mode asynchrone, la totalité de la file d'attente sera supprimée afin d'éviter que des flots de WAL ne passent avant que la limite de la file ne soit à nouveau dépassée.

                        Le but de cette fonction est d'éviter que le disque utilisé pour le stockage du journal (pg_wal ou pg_log) ne se remplisse, ce qui entraînerait l'arrêt complet de l'instance  <postgres/>.  Il est peut être préférable de perdre la sauvegarde que d'avoir <postgres/> s'arrêter.

                        La taille peut être saisie en octets (par défaut) ou en KB, MB, GB, TB ou PB où le multiplicateur est une puissance de 1024.</text>

                        <example>1GB</example>
                    </config-key>

                    <!-- ======================================================================================================= -->
                    <config-key id="archive-timeout" name="Archive Délai d'attente">
                        <summary>Délai d'attente de l'archivage (archive timeout).</summary>

                        <text>Définit le temps maximum, en secondes, à attendre pour que chaque segment WAL atteigne le dépôt d'archives de <backrest/>.  Le délai s'applique aux commandes <cmd>check</cmd> et <cmd>backup</cmd> lorsqu'on attend que les segments WAL nécessaires à la cohérence de la sauvegarde soient archivés.</text>

                        <example>30</example>
                    </config-key>
                </config-key-list>
            </config-section>

            <!-- CONFIG - RESTORE -->
            <config-section id="restore" name="Restore">
                <text>La section <setting>restore</setting> définit les paramètres utilisés lors de la restauration des sauvegardes.</text>

                <config-key-list>
                    <!-- CONFIG - RESTORE SECTION - DB-INCLUDE KEY -->
                    <config-key id="db-include" name="Inclure la base de données">
                        <summary>Restaurer uniquement des bases de données spécifiques.</summary>

                        <text>Cette fonctionnalité permet de ne restaurer que certaines bases de données.  Les bases de données qui ne sont pas spécifiquement sélectionnées seront restaurées sous la forme de fichiers épars et mis à zéro afin d'économiser de l'espace, tout en permettant à <postgres/> d'effectuer la restauration.  Après la récupération, les bases de données qui n'ont pas été incluses ne seront pas accessibles mais peuvent être supprimées avec la commande <id>drop database</id>.  <admonition type="note">Les bases de données intégrées (<id>template0</id>, <id>template1</id>, et <id>postgres</id>) sont toujours restaurées.</admonition>L'option <setting>{[dash]}-db-include</setting> peut être passée plusieurs fois pour spécifier plus d'une base de données à inclure.</text>

                        <example>db_main</example>
                    </config-key>

                    <!-- CONFIG - RESTORE SECTION - LINK-ALL KEY -->
                    <config-key id="link-all" name="Tous Liens synboliques">
                        <summary>Restaurer tous les liens symboliques</summary>

                        <text>Par défaut, les liens symboliques qu'ils soient répertoires ou fichiers sont restaurés comme des répertoires et fichiers standards dans $PGDATA.  En effet, il peut être dangereux de restaurer des liens symboliques vers leur destination d'origine sur un système autre que celui où la sauvegarde d'origine a été effectuée.  Cette option restaure tous les liens symboliques tels qu'ils étaient sur le système d'origine où la sauvegarde a été effectuée.</text>

                        <example>y</example>
                    </config-key>

                    <!-- CONFIG - RESTORE SECTION - LINK-MAP KEY -->
                    <config-key id="link-map" name="Mappage liens symboliques">
                        <summary>Modification de la destination d'un lien symbolique.</summary>

                        <text>Permet de modifier la destination du fichier ou du répertoire d'un lien symbolique lors de la restauration.  Ceci est utile lors de la restauration sur un sytèmes avec une configuration du stockage différente de celle du système d'origine (là où la sauvegarde a été réalisée).</text>

                        <example>pg_xlog=/data/xlog</example>
                    </config-key>

                    <!-- CONFIG - RESTORE SECTION - RECOVERY-OPTION KEY -->
                    <config-key id="recovery-option" name="Option Récuperation">
                        <summary>Définissez une option dans <file>recovery.conf</file>.</summary>

                        <text>Consultez http://www.postgresql.org/docs/X.X/static/recovery-config.html pour plus de détails sur les options de recovery.conf (remplacez X.X par votre <postgres/> version).  Cette option peut être utilisée plusieurs fois.<admonition type="note">L'option <setting>restore_command</setting> sera générée automatiquement mais peut être écrasée avec cette option.  Faites attention à bien spécifier votre propre <setting>restore_command</setting> car <backrest/> est conçu pour gérer cela pour vous.  Les options Target Recovery (recovery_target_name, recovery_target_time, etc.) sont générées automatiquement par <backrest/> et ne doivent pas être définies avec cette option.</admonition>Dans la mesure où <backrest/> ne démarre pas <postgres/> après avoir écrit le fichier <file>recovery.conf</file>, il est toujours possible de modifier/contrôler <file>recovery.conf</file> avant de redémarrer manuellement.</text>

                        <example>primary_conninfo=db.mydomain.com</example>
                    </config-key>

                    <!-- CONFIG - RESTORE SECTION - TABLESPACE-MAP KEY -->
                    <config-key id="tablespace-map" name="Mappage Tablespace">
                        <summary>Restaurer un tablespace dans un répertoire spécifique.</summary>

                        <text>Déplace un tablespace vers un nouvel emplacement pendant la restauration.  Cela est utile lorsque les emplacements des tablespaces ne sont pas les mêmes sur un secondaire en réplication, ou lorsqu'un système a des points de montage différents après une mis à niveau.

                        Depuis la version <postgres/> 9.2, les emplacements des tablespaces ne sont pas stockés dans pg_tablespace, donc le déplacement des tablespaces peut se faire en toute tranquillité.  Cependant, le déplacement d'un tablespace vers le <setting>data_directory</setting> n'est pas recommandé et peut causer des problèmes.  Pour plus d'informations sur le déplacement des tablespaces, http://www.databasesoup.com/2013/11/moving-tablespaces.html est une bonne ressource (en anglais).</text>

                        <example>ts_01=/db/ts_01</example>
                    </config-key>

                    <!-- CONFIG - RESTORE SECTION - TABLESPACE KEY -->
                    <config-key id="tablespace-map-all" name="Remappage Tous Tablespaces">
                        <summary>Restaurez tous les tablespaces dans le répertoire spécifié.</summary>

                        <text>Par défaut, les tablespaces sont restaurés à leur emplacement d'origine et, bien que ce comportement puisse être modifié avec l'option <setting>tablespace-map</setting>, il est parfois souhaitable de remapper tous les tablespaces dans un nouveau répertoire en une seule fois.  Ceci est particulièrement utile pour les systèmes de développement ou de mise en place qui peuvent ne pas avoir la même disposition de stockage que le système d'origine où la sauvegarde a été réalisée.

                        Le chemin spécifié sera le chemin parent utilisé pour créer tous les tablespaces de la sauvegarde lors de la restauration.</text>

                        <example>/data/tablespace</example>
                    </config-key>
                </config-key-list>
            </config-section>

            <!-- CONFIG - STANZA -->
            <config-section id="stanza" name="Stanza">
                <text>Un stanza définit la configuration de sauvegarde d'une instance de base de données <postgres/> déterminé.  La section stanza doit définir le chemin de l'instance de base de données et l'hôte/utilisateur si l'instance de base de données est distante.  De plus, toute section de configuration globale peut être écrasée pour définir des paramètres spécifiques au stanza.

                <b>Indexation</b> : Toutes les options <setting>pg-</setting> sont indexées pour permettre la configuration de plusieurs hôtes <postgres/> . Par exemple, un seul primaire est configurée avec les options <setting>pg1-path</setting>, <setting>pg1-port</setting>, etc.  Si un secondaire (standby) est configuré, alors les options <setting>pg-</setting> sur l'hôte du dépôt sont indexées comme <setting>pg2-</setting> (par exemple pg2-host, pg2-path, etc).</text>

                <config-key-list>
                    <!-- CONFIG - STANZA SECTION - PG-HOST-CMD KEY -->
                    <config-key id="pg-host-cmd" name="Hôte PostgreSQL Commande">
                        <summary>Emplacement des exécutable <backrest/> sur l'hôte <postgres/>.</summary>

                        <text>Uniquement requis si le chemin vers <exe/> est différent sur le serveur local et <postgres/>.  S'il n'est pas défini, le chemin de l'<exe/> de l'hôte de la base de données sera le même que le chemin de l'<exe/> local.</text>

                        <default>identique au local</default>
                        <example>/usr/lib/backrest/bin/pgbackrest</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-HOST-CONFIG KEY -->
                    <config-key id="pg-host-config" name="Hôte PostgreSQL Configuration">
                        <summary><backrest/> database host configuration file.</summary>

                        <text>Définit l'emplacement du fichier de configuration sur l'hôte <postgres/>.  Ceci n'est requis que si le fichier de configuration de l'hôte <postgres/> se trouve dans un emplacement différent de celui du fichier de configuration local.</text>

                        <example>/conf/pgbackrest/pgbackrest.conf</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-HOST-CONFIG-INCLUDE-PATH KEY -->
                    <config-key id="pg-host-config-include-path" name="Hôte PostgreSQL Chemin inclusion Configuration">
                        <summary>Chemin d'inclusion de la configuration <backrest/> sur l'hôte.</summary>

                        <text>Définit l'emplacement du chemin d'inclusion de la configuration sur l'hôte <postgres/>.  Ceci n'est requis que si le chemin d'inclusion de la configuration de l'hôte <postgres/> se trouve à un endroit différent du chemin d'inclusion de la configuration locale.</text>

                        <example>/conf/pgbackrest/conf.d</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-HOST-CONFIG-PATH KEY -->
                    <config-key id="pg-host-config-path" name="Hôte PostgreSQL Chemin Configuration">
                        <summary>Chemin de configuration <backrest/> de l'hôte de base de données.</summary>

                        <text>Définit l'emplacement du chemin de configuration sur l'hôte <postgres/>.  Ceci n'est requis que si le chemin de configuration de l'hôte <postgres/> se trouve dans un emplacement différent du chemin de configuration local.</text>

                        <example>/conf/pgbackrest</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-HOST KEY -->
                    <config-key id="pg-host" name="Hôte PostgreSQL">
                        <summary>Hôte <postgres/> pour les opérations à distance via SSH.</summary>

                        <text>Utilisé pour les sauvegardes lorsque l'hôte <postgres/> est différent de l'hôte du dépôt.</text>

                        <example>db.domain.com</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-HOST-USER KEY -->
                    <config-key id="pg-host-user" name="Hôte PostgreSQL Utilisateur">
                        <summary>Utilisateur de connexion <postgres/> lorsque <setting>pg-host</setting> est défini.</summary>

                        <text>Cet utilisateur sera également propriétaire du processus distant <backrest/> et initiera les connexions à <postgres/>.  Pour que cela puisse fonctionner correctement, l'utilisateur doit être le propriétaire de l'instance de base de données <postgres/>, qui est généralement par défaut <id>postgres</id>.</text>

                        <example>db_owner</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-PATH KEY -->
                    <config-key id="pg-path" name="PostgreSQL Chemin">
                        <summary><postgres/> data directory.</summary>

                        <text>Ce paramètre doit être le même que le paramètre <setting>data_directory</setting> du fichier <file>postgresql.conf</file>.  Même si cette valeur peut être lue à partir de <file>postgresql.conf</file> ou <postgres/>, il est conseillé de la définir au cas où ces ressources ne seraient pas disponibles pendant un scénario de restauration ou de sauvegarde hors ligne.

                        L'option <setting>pg-path</setting> est testée par rapport à la valeur indiquée par <postgres/> à chaque sauvegarde en ligne, elle doit donc toujours être à jour.</text>

                        <example>/data/db</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-PORT KEY -->
                    <config-key id="pg-port" name="PostgreSQL Port">
                        <summary>Port <postgres/>.</summary>

                        <text>Port sur lequel <postgres/> écoute.  Il n'est généralement pas nécessaire de le préciser car la plupart des instances <postgres/> fonctionnent sur le port par défaut.</text>

                        <example>6543</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-SOCKET-PATH KEY -->
                    <config-key id="pg-socket-path" name="PostgreSQL Emplacement Socket Unix">
                        <summary>Emplacement socket unix <postgres/>.</summary>

                        <text>Le répertoire de la socket unix qui a été spécifié au démarrage de <postgres/>.  <backrest/> trouvera automatiquement l'emplacement standard pour votre système d'exploitation, il n'est donc généralement pas nécessaire de spécifier ce paramètre, sauf si le répertoire des sockets a été explicitement modifié avec le paramètre <setting>unix_socket_directory</setting> dans <file>postgresql.conf</file>.</text>

                        <example>/var/run/postgresql</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-USER KEY -->
                    <config-key id="pg-user" name="PostgreSQL Utilisateur Base de données">
                        <summary>Nom d'utilisateur de base de données <postgres/>.</summary>

                        <text>Le nom d'utilisateur de la base de données utilisé lors de la connexion à <postgres/>.  S'il n'est pas spécifié, <backrest/> se connectera avec l'utilisateur du système d'exploitation local ou <id>PGUSER</id>.</text>

                        <example>backupuser</example>
                    </config-key>

                    <!-- CONFIG - STANZA SECTION - PG-HOST-PORT KEY -->
                    <config-key id="pg-host-port" name="Hôte PostgreSQL Port">
                        <summary>Port de l'hôte <postgres/> lorsque <setting>pg-host</setting> est configuré.</summary>

                        <text>Utiliser cette option pour spécifier un port non par défaut pour le protocole hôte <postgres/>.  Actuellement, seul le protocole SSH est pris en charge</text>

                        <example>25</example>
                    </config-key>
                </config-key-list>
            </config-section>
        </config-section-list>
    </config>

    <!-- COMMAND -->
    <operation title="{[project]} Référence de commandes">
        <description>La référence de commandes de {[projet]} détaille toutes les commandes et options.</description>

        <text>Les commandes sont utilisées pour exécuter les différentes fonctionnalités de <backrest/>.  Ici, les options de commande sont énumérées de manière détaillée, autrement dit, chaque option applicable à une commande est énumérée avec cette commande, même si elle s'applique à une ou plusieurs autres commandes.  Cela inclut toutes les options qui peuvent également être configurées dans <file>pgbackrest.conf</file>.

        Les options non booléennes configurées dans <file>pgbackrest.conf</file> peuvent être réinitialisées à la valeur par défaut lors de l'appel en ligne de commande en utilisant le préfixe <id>reset-</id>.   Cette fonctionnalité peut être utilisée afin de restaurer une sauvegarde directement sur le serveur du dépôt.  Normalement, <backrest/> sera en erreur car il detectera que l'hôte de la base de données est distant et que la restauration ne peut pas être faites à distance.  En ajoutant <br-option>--reset-pg1-host</br-option> sur la ligne de commande, <backrest/> ignorera l'hôte de base de données distant et restaurera localement.  Il peut être nécessaire de passer un nouveau <br-option>--pg-path</br-option> pour forcer la restauration à se faire dans un chemin spécifique, c'est-à-dire pas le chemin utilisé sur l'hôte d'instance de la base de données.

        Le préfixe <id>no-</id> peut être utilisé pour définir une option booléenne à false (faux) sur la ligne de commande.

        Toute option peut être définie dans une variable d'environnement en utilisant le préfixe <id>PGBACKREST_</id> et le nom de l'option en toutes lettres majuscules en remplaçant <id>-</id> par <id>_</id>, par exemple, <br-option>pg1-path</br-option> devient <id>PGBACKREST_PG1_PATH</id> et <br-option>stanza</br-option> devient <id>PGBACKREST_STANZA</id>.  Les options booléennes sont représentées comme elles le seraient dans un fichier de configuration, par exemple <id>PGBACKREST_COMPRESS="n"</id>, et les variantes <id>reset-*</id> ne sont pas autorisées.  Les options qui peuvent être spécifiées plusieurs fois sur la ligne de commande ou dans un fichier de configuration peuvent être représentées en séparant les valeurs par des deux points, par exemple <id>PGBACKREST_DB_INCLUDE="db1:db2"</id>.

        Les options de la ligne de commande écrasent les options de l'environnement qui écrasent, elles, les options du fichier de configuration.</text>

        <operation-general title="General Options">
            <option-list>
                <!-- OPERATION - GENERAL - CIPHER-PASS OPTION -->
                <option id="cipher-pass" name="Phrase de passe Ponctuelle chiffrement">
                    <summary>Phrase secrète de chiffrement pour la commande en cours.</summary>

                    <text>Spécifier une phrase secrète ponctuelle utilisé pour le chiffrement avec la commande en cours.

                    <b>POUR UN USAGE INTERNE UNIQUEMENT. NE PAS UTILISER EN PRODUCTION..</b></text>

                    <example>zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO</example>
                </option>

                <!-- OPERATION - GENERAL - CONFIG OPTION -->
                <option id="config" name="Config">
                    <summary>Fichier de configuration <backrest/>.</summary>

                    <text>Utiliser cette option pour spécifier un fichier de configuration différent de celui par défaut.</text>

                    <example>/conf/pgbackrest/pgbackrest.conf</example>
                </option>

                <!-- OPERATION - GENERAL - CONFIG INCLUDE PATH OPTION -->
                <option id="config-include-path" name="Config Include Path">
                    <summary>Emplacement des fichiers de configuration <backrest/> supplémentaires..</summary>

                    <text>Les fichiers de configuration existant à l'emplacement spécifié avec l'extension <file>.conf</file> seront concaténés avec le fichier de configuration <backrest/>, ce qui donne un seul fichier de configuration.</text>

                    <example>/conf/pgbackrest/conf.d</example>
                </option>

                <!-- OPERATION - GENERAL - CONFIG PATH OPTION -->
                <option id="config-path" name="Emplacement configuration">
                    <summary>Emplacement du répertoire de racine de <backrest/> des fichiers de configuration.</summary>

                    <text>Ce paramètre est utilisé pour écraser le chemin racine par défaut pour les options <br-option>--config</br-option> et <br-option>--config-include-path</br-option> à moins qu'elles ne soient explicitement définies sur la ligne de commande.

                    Par exemple, en utilisant uniquement <code>--config-path=/conf/pgbackrest</code>, la valeur par défaut de <br-option>--config</br-option> est <code>/conf/pgbackrest/pgbackrest.conf</code> et la valeur par défaut de <br-option>--config-include-path</br-option> est <code>/conf/pgbackrest/conf.d</code>.</text>

                    <example>/conf/pgbackrest</example>
                </option>

                <!-- OPERATION - GENERAL - DRY-RUN OPTION -->
                <option id="dry-run" name="Dry Run">
                    <summary>Executer une commande en mode essai (dry-run).</summary>

                    <text>L'option <br-option>{[dash]}-dry-run</br-option> est une option utilisable uniquement en ligne de commande et peut être utilisée lorsqu'il est nécessaire de déterminer les modifications qui seront apportées par la commande sans que celle-ci n'apporte réellement de modifications.</text>

                    <example>y</example>
                </option>

                <!-- OPERATION - GENERAL - RAW -->
                <option id="raw" name="Données brutes Raw Data">
                    <summary>Ne pas transformer les données.</summary>

                    <text>Ne pas transformer (c'est-à-dire crypter, décompresser, etc.) les données pour la commande en cours.</text>

                    <example>y</example>
                </option>

                <!-- OPERATION - GENERAL - STANZA OPTION -->
                <option id="stanza" name="Stanza">
                    <summary>Defines the stanza.</summary>

                    <text>Un stanza est la configuration de la sauvegarde d'une instance <postgres/>  où est définit l'endroit où il se trouve, la façon dont il sera sauvegardé, les options d'archivage, etc...  La plupart des serveurs de base de données n'auront qu'une seule instance  <postgres/> et donc un stanza alors que les serveurs de sauvegarde auront un stanza pour chaque instance de base de données qui doit être sauvegardé.

                    Il est tentant de nommer le stanza en référence à l'instance primaire, mais un meilleur nom décrirait les bases de données contenues dans l'instance :  comme le nom du stanza sera utilisé pour le primaire et tous les secondaire, il est plus approprié de choisir un nom qui décrit la fonction réelle du groupe d'instances, comme app ou dw, plutôt que le nom local de l'instance, comme main ou prod.</text>

                    <example>main</example>
                </option>
            </option-list>
        </operation-general>

        <command-list title="Commands">
            <!-- OPERATION - BACKUP COMMAND -->
            <command id="backup" name="Sauvegarde">
                <summary>Sauvegarder une instance de bases de données.</summary>

                <text><backrest/> n'a pas de planificateur de taches intégré, il est donc conseillé de l'exécuter à partir de cron ou d'un autre système de planification.</text>

                <option-list>
                    <!-- OPERATION - BACKUP COMMAND - TYPE OPTION -->
                    <option id="type" name="Type">
                        <summary>Type de sauvegarde.</summary>

                        <text>Les types de sauvegarde ci-dessous sont pris en charge:
                            <ul>
                                <li><id>full</id> - tous les fichiers de l'instance de bases de données seront copiés et il n'y aura aucune dépendance par rapport aux sauvegardes précédentes.</li>
                                <li><id>incr</id> - incrémentale basé sur la dernière sauvegarde complète réussit.</li>
                                <li><id>diff</id> - comme une sauvegarde incrémentale mais toujours basée sur la dernière sauvegarde complète.</li>
                            </ul></text>

                        <example>full</example>
                    </option>

                    <!-- OPERATION - BACKUP COMMAND - FORCE OPTION -->
                    <option id="force" name="Forcer">
                        <summary>Forcer une sauvegarde hors ligne.</summary>

                        <text>Lorsqu'il est utilisé avec <br-option>--no-start-stop</br-option> une sauvegarde sera exécutée même si <backrest/> pense que <postgres/> est en cours d'exécution.  <b>Cette option doit être utilisée avec une extrême prudence car elle risque d'entraîner une sauvegarde incorrecte.</b>

                        Il y quelques scénarios où une telle sauvegarde pourrait encore être utile dans ces conditions.  Par exemple, si un serveur tombe en panne et que le volume de l'instance de base de données ne peut être monté qu'en lecture seule, il serait judicieux d'effectuer une sauvegarde même si <file>postmaster.pid</file> est présent.  Dans ce cas, il serait plus intéressant de revenir à la sauvegarde précédente et de rejouer le WAL, mais il est possible qu'il y ait une transaction très importante dans un segment du WAL qui n'a pas été archivé.</text>

                        <example>y</example>
                    </option>

                    <!-- ======================================================================================================= -->
                    <option id="online" name="Online">
                        <summary>Effectuer une sauvegarde en ligne.</summary>

                        <text>Le fait de spécifier --no-online empêche <backrest/> de lancer <code>pg_start_backup()</code> et <code>pg_stop_backup()</code> sur l'instance de la base de données.  Pour que --no-online fonctionne, l'instance <postgres/> doit être arrêté sinon <backrest/> générera une erreur.

                        L'objectif de cette option est de permettre des sauvegardes hors ligne.  Le répertoire <path>pg_xlog</path>/<path>pg_wal</path> est copié tel quel et <setting>archive-check</setting> est automatiquement désactivé lors de la sauvegarde.</text>

                        <example>n</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Sauvegarde complète">
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db --type=full backup
                        </code-block>
                        Faire une sauvegarde du stanza  <id>db</id>.  <br-option>--type</br-option> peut également être réglé sur <id>incr</id> ou <id>diff</id> pour des sauvegardes incrémentielles ou différentielles.  Cependant, si aucune sauvegarde <id>full</id> n'existe, une sauvegarde <id>full</id> sera forcée même si <id>incr</id> ou <id>diff</id> est demandés.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - ARCHIVE-PUSH COMMAND -->
            <command id="archive-push" name="Pousser Archive">
                <summary>Pousser un segment de WAL vers les archives.</summary>

                <text>Un segment WAL peut être poussé immédiatement vers les archives ou stocké localement selon la valeur de <setting>archive-async</setting></text>

                <command-example-list>
                    <command-example>
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db archive-push %p
                        </code-block>
                        Accepte un segment WAL de <postgres/> et l'archive dans le dépôt défini par <setting>repo-path</setting>.  <id>%p</id> est la façon dont <postgres/> spécifie l'emplacement du segment WAL à archiver.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - ARCHIVE-GET COMMAND -->
            <command id="archive-get" name="Récupération Archive">
                <summary>Récuperation d'un segments WAL à partir des archives.</summary>

                <text>Les segments WAL sont nécessaires pour restaurer une instance <postgres/> ou pour maintenir une réplication.</text>

                <command-example-list>
                    <command-example>
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db archive-get %f %p
                        </code-block>
                        Récupère un segment WAL depuis le dépôt de sauvegarde.  Cette commande est configuré dans <file>recovery.conf</file> lors d'une restauration de sauvegarde, afin d'effectuer un PITR, ou comme alternative au streaming pour garder un réplica à jour. <id>%f</id> est la variable utilisé par <postgres/> pour spécifier le segment WAL dont il a besoin et <id>%p</id> est l'emplacement où il doit être copié.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - CHECK COMMAND -->
            <command id="check" name="Vérification">
                <summary>Vérification de la configuration.</summary>

                <text>La commande <cmd>check</cmd> valide que <backrest/> et le paramétre <pg-setting>archive_command</pg-setting> sont configurés correctement pour l'archivage et les sauvegardes. Il détecte d'éventuelles erreurs de configuration, en particulier pour l'archivage. Une mauvaise configuration de l'archivage se traduit par des sauvegardes incomplètes : les segments WAL requis n'étant pas parvenus aux archives. La commande peut être exécutée sur le serveur de l'instance de la base de données ou sur le serveur du dépôt de sauvegarde.  La commande peut également être exécutée sur l'hôte secondaire (standby), mais comme les commandes <code>pg_switch_xlog()</code>/<code>pg_switch_wal()</code> ne peut pas être exécuté sur une instance secondaire, la commande ne testera que la configuration du dépôt.

                Notez que <code>pg_create_restore_point('pgBackRest Archive Check')</code> et <code>pg_switch_xlog()</code>/<code>pg_switch_wal()</code> sont appelés pour forcer <postgres/> à archiver un segment WAL. Les points de restauration ne sont supportés que dans <postgres/> &gt;= 9.1; Pour les versions plus anciennes, la commande <cmd>check</cmd> peut échouer s'il n'y a pas eu d'activité d'écriture depuis la dernière rotation du journal, il est donc recommandé que l'activité soit générée par l'utilisateur s'il n'y a pas eu d'écriture depuis le dernier changement de WAL avant l'exécution de la commande <cmd>check</cmd></text>

                <command-example-list>
                    <command-example>
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db check
                        </code-block>
                        </text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - EXPIRE COMMAND -->
            <command id="expire" name="Expiration">
                <summary>Expiration des sauvegardes qui dépassent la rétention.</summary>

                <text><backrest/> effectue la rotation des sauvegardes mais ne se préoccupe pas de savoir quand les sauvegardes ont été créées.  Si deux sauvegardes complètes sont configurées pour être conservées, <backrest/> conservera deux sauvegardes complètes, qu'elles aient lieu à deux heures ou à deux semaines d'intervalle.</text>

                <option-list>
                    <!-- OPERATION - EXPIRE COMMAND - SET OPTION -->
                    <option id="set" name="Definir">
                        <summary>Definir l'expiration de la sauvegarde.</summary>

                        <text>Le jeu de sauvegarde spécifié (c'est-à-dire l'étiquette de sauvegarde fournie et toutes ses sauvegardes dépendantes, le cas échéant) expirera quelles que soient les règles de conservation des sauvegardes, excepté qu'au moins une sauvegarde complète doit rester dans le dépôt. <admonition type="warning">Utilisez cette option avec une extrême prudence &amp;mdash ; elle supprimera définitivement toutes les sauvegardes et archives non nécessaires pour effectuer une sauvegarde cohérente du dépôt de sauvegarde <backrest/> pour le jeu de sauvegarde spécifié. Ce processus peut empêcher l'exécution du PITR. Si les options <br-option>--repo-retention-full</br-option> et/ou <br-option>--repo-retention-archive</br-option> sont configurées, alors il est conseillé de remplacer ces options en définissant leurs valeurs au maximum lors de l'exécution de la commande d'expiration.</admonition></text>
                        <example>20150131-153358F_20150131-153401I</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example>
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db expire
                        </code-block>
                        Expiration (rotation) de toutes les sauvegardes qui dépassent la durée de conservation définie.  L'expiration est exécutée automatiquement après chaque sauvegarde réussie, il n'est donc pas nécessaire d'exécuter cette commande séparément, sauf si vous avez réduit la rétention, généralement pour libérer de l'espace.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - REPO-CREATE COMMAND -->
            <command id="repo-create" name="Création dépôt">
                <summary>Créer le dépôt.</summary>

                <text>Création du bucket si l'option <setting>repo-type=s3</setting>.

                <b>POUR UN USAGE INTERNE UNIQUEMENT. NE PAS UTILISER EN PRODUCTION.</b></text>

                <command-example-list>
                    <command-example title="Créer un dépôt">
                        <text><code-block title="">
                            {[backrest-exe]} repo-create
                        </code-block>

                      Créer un dépôt.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - REPO-GET COMMAND -->
            <command id="repo-get" name="Obtenir un fichier du dépôt">
                <summary>Obtenir un fichier du dépôt.</summary>

                <text>Similaire à la commande unix <cmd>cat</cmd> mais les options sont différentes.</text>

                <option-list>
                    <!-- OPERATION - REPO-GET COMMAND - IGNORE-MISSING OPTION -->
                    <option id="ignore-missing" name="Ignorer les manquants">
                        <summary>Ignorer le fichier source manquant.</summary>

                        <text>Se termine avec un code de sortie à 1 si le fichier source est manquant mais n'affiche pas d'erreur.</text>

                        <example>y</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Obtenir un fichier du dépôt">
                        <text><code-block title="">
                            {[backrest-exe]} repo-get backup/demo/file.txt
                        </code-block>

                        Obtenir un fichier du stanza demo.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - REPO-LS COMMAND -->
            <command id="repo-ls" name="Liste des chemins/dossiers du dépôt">
                <summary>Lister les chemins/fichiers du dépôt.</summary>

                <text>Similaire à la commande unix <cmd>ls</cmd> mais les options et la sortie sont différentes.  Seules les informations fournies par les pilotes de stockage du référentiel sont disponibles : <id>name</id> (nom), <id>type</id>(type), <id>size</id> (taille), <id>time</id> (date de modification), et <id>destination</id> (destination sur les système prennent en charge les liens).</text>

                <option-list>
                    <!-- OPERATION - LS COMMAND - FILTER OPTION -->
                    <option id="filter" name="Filtre de sortie">
                        <summary>Filtrer la sortie avec une expression régulière.</summary>

                        <text>Le filtre est appliqué sur les noms de fichiers/chemins d'accès avant l'affichage sur la sortie.</text>

                        <example>(F|D|I)$</example>
                    </option>

                    <!-- OPERATION - LS COMMAND - OUTPUT OPTION -->
                    <option id="output" name="Sortie">
                        <summary>Format de sortie.</summary>

                        <text>Les types de sortie suivants sont pris en charge:
                        <ul>
                            <li><id>text</id> - Liste simple avec un nom de fichier/lien/chemin sur chaque ligne.</li>
                            <li><id>json</id> - Informations détaillées sur les fichier/lien/dossier au format JSON.</li>
                        </ul></text>

                        <example>json</example>
                    </option>

                    <!-- OPERATION - LS COMMAND - RECURSE OPTION -->
                    <option id="recurse" name="Récursivité des sous-chemins">
                        <summary>Inclure tous les sous-chemins dans la sortie.</summary>

                        <text>Tous les sous-chemins et leurs fichiers seront inclus dans le résultat.</text>

                        <example>y</example>
                    </option>

                    <!-- OPERATION - LS COMMAND - SORT OPTION -->
                    <option id="sort" name="Tri de sortie">
                        <summary>Trier la sortie par ordre croissant, décroissant ou aucun.</summary>

                        <text>Les types de tri suivants sont pris en charge:
                        <ul>
                            <li><id>asc</id> - tri croissant.</li>
                            <li><id>desc</id> - tri décroissant.</li>
                            <li><id>none</id> - pas de tri.</li>
                        </ul></text>

                        <example>desc</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Liste de toutes les sauvegardes d'un stanza">
                        <text><code-block title="">
                            {[backrest-exe]} repo-ls backup/demo
                        </code-block>

                        Liste de toutes les sauvegardes du stanza demo.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - REPO-PUT COMMAND -->
            <command id="repo-put" name="Déposer un ficher">
                <summary>Déposer un fichier dans le dépôt.</summary>

                <text>Similaire à la commande unix <cmd>tee</cmd> mais avec des options différentes.

                <b>POUR UN USAGE INTERNE UNIQUEMENT. NE PAS UTILISER EN PRODUCTION.</b></text>

                <command-example-list>
                    <command-example title="Déposer un fichier dans le dépôt">
                        <text><code-block title="">
                            cat file.txt {[backrest-exe]} repo-put backup/demo/file.txt
                        </code-block>

                        Déposer un fichier dans le stanza demo.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - RM COMMAND -->
            <command id="repo-rm" name="Supprimer les chemins/dossiers du dépôt">
                <summary>Supprimer les chemins/fichiers dans le dépôt.</summary>

                <text>Similaire à la commande unix <cmd>rm</cmd> mais avec des options différentes.

                <b>POUR UN USAGE INTERNE UNIQUEMENT. NE PAS UTILISER EN PRODUCTION.</b></text>

                <option-list>
                    <!-- OPERATION - RM COMMAND - RECURSE OPTION -->
                    <option id="recurse" name="Récursivité des sous-chemins">
                        <summary>Supprimer tous les sous-fichiers/répertoire</summary>

                        <text>Tous les sous-chemins et leurs fichiers seront supprimés.</text>

                        <example>y</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Supprimer une sauvegarde">
                        <text><code-block title="">
                            {[backrest-exe]} rm --recurse backup/demo/20190718-155825F
                        </code-block>

                        Supprimer la sauvegarde 20190718-155825F dans le stanza demo.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - RESTORE COMMAND -->
            <command id="restore" name="Restauration">
                <summary>Retaurer une instance de base de données.</summary>

                <text>This command is generally run manually, but there are instances where it might be automated.</text>

                <option-list>
                    <!-- OPERATION - RESTORE COMMAND - SET OPTION -->
                    <option id="set" name="Jeu">
                        <summary>Jeu de sauvegarde à restaurer.</summary>

                        <text>Le jeu de sauvegarde à restaurer : <id>latest</id> restaurera la dernière sauvegarde, autrement fournir le nom de la sauvegarde à restaurer</text>
                        <example>20150131-153358F_20150131-153401I</example>
                    </option>

                    <!-- OPERATION - RESTORE COMMAND - FORCE OPTION -->
                    <option id="force" name="Force">
                        <summary>Forcer une restauration.</summary>

                        <text>En soi, cette option écrase complètement les chemins des données et des tablespaces de <postgres/>.  En association avec <br-option>--delta</br-option>, un delta sera effectué en se basant sur l'horodatage et la taille au lieu des sommes de contrôle.</text>

                        <example>y</example>
                    </option>

                    <!-- OPERATION - RESTORE COMMAND - TYPE OPTION -->
                    <option id="type" name="Type">
                        <summary>Type de récupération.</summary>

                        <text>Les types de récupération suivants sont pris en charge:
                        <ul>
                            <li><id>default</id> - récupération jusqu'à la fin du flux d'archives.</li>
                            <li><id>immediate</id> - récupération uniquement jusqu'à ce que la base de données devienne cohérente. Cette option n'est prise en charge que sur <postgres/> &gt;= 9.4.</li>
                            <li><id>name</id> - récupération jusqu'au point de restauration spécifié dans <br-option>--target</br-option>.</li>
                            <li><id>xid</id> - récupération jusqu'à l'ID de transaction specifié dans <br-option>--target</br-option>.</li>
                            <li><id>time</id> - se récupération jusqu'au moment spécifié dans <br-option>--target</br-option>.</li>
                            <li><id>preserve</id> - préserver la configuration de la récupération (ex fichier <file>recovery.conf</file>).</li>
                            <li><id>standby</id> - ajoute <setting>standby_mode=on</setting> au option de récupération de <postgres/> (ex: <file>recovery.conf</file>) pour que l'instance démarre en mode standby.</li>
                            <li><id>none</id> - Aucune configuration de récupération n'est écrite dans <postgres/> (ex : <file>recovery.conf</file>). <postgres/> tentera d'obtenir une cohérence en utilisant les segments WAL présents dans <path>pg_xlog</path>/<path>pg_wal</path>. Fournissez les segments WAL requis ou utilisez le paramètre <setting>archive-copy</setting> pour les inclure avec la sauvegarde.</li>
                        </ul></text>
                        <example>xid</example>
                    </option>

                    <!-- OPERATION - RESTORE COMMAND - TARGET OPTION -->
                    <option id="target" name="Target">
                        <summary>Cible de récupération target.</summary>

                        <text>Définit la cible de récupération lorsque <br-option>--type</br-option> est <id>nom</id>, <id>xid</id>, ou <id>temps</id></text>
                        <example>2015-01-30 14:15:11 EST</example>
                    </option>

                    <!-- OPERATION - RESTORE COMMAND - TARGET-EXCLUSIVE OPTION -->
                    <option id="target-exclusive" name="Cible Exclusive">
                        <summary>S'arrêter juste avant que l'objectif de récupération ne soit atteint.</summary>

                        <text>Définit si la cible de récupération est exclusive (la valeur par défaut est inclusive) et n'est valable que lorsque <br-option>--type</br-option> est <id>time</id> ou <id>xid</id>.  Par exemple, l'utilisation de <br-option>--target-exclusive</br-option> exclurait le contenu de la transaction <id>1007</id> lorsque <br-option>--type=xid</br-option> et <br-option>--target=1007</br-option>.  Pour plus d'information, consultez  dans la documentation de <postgres/> l'option <setting>recovery_target_inclusive</setting>.</text>

                        <example>n</example>
                    </option>

                    <!-- OPERATION - RESTORE COMMAND - TARGET-RESUME OPTION -->
                    <option id="target-action" name="Target Action">
                        <summary>Action à prendre lorsque la cible de récupération est atteint.</summary>

                        <text>Cette option est effective lorsque <setting>hot_standby=on</setting>  est configuré dans  <postgres/> (ex : <file>postgresql.conf</file>); sans quoi l'instance sera promu lorsque la cible sera atteinte ou lorsqu'il n'y plus d'autre WAL archivé.

                            Les actions suivantes sont supportées:
                        <ul>
                            <li><id>pause</id> - mise en pause lorsque la cible de récupération est atteint. (<postgres/> &gt;= 9.1)</li>
                            <li><id>promote</id> - promotion et changement de timeline lorsque la cible de récupération est atteint. (<postgres/> &gt;= 9.1)</li>
                            <li><id>shutdown</id> -  arrêt du serveur lorsque la cible de récupération est atteint (<postgres/> &gt;= 9.5)</li>
                        </ul></text>

                        <example>promote</example>
                    </option>

                    <!-- OPERATION - RESTORE COMMAND - TARGET-TIMELINE OPTION -->
                    <option id="target-timeline" name="Target Timeline">
                        <summary>Récupération jusqu'à une timeline.</summary>

                        <text>Voir <setting>recovery_target_timeline</setting> dans la documentation de <postgres/> pour plus d'informations</text>

                        <example>3</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Restaurer le dernier">
                        <text><code-block title="">
                                {[backrest-exe]} --stanza=db --type=name --target=release restore
                            </code-block>
                            Restaure la dernière sauvegarde de l'instance <postgres/>, jusqu'au point de restauration <id>release</id></text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - INFO COMMAND -->
            <command id="info" name="Info">
                <summary>Récupérer des informations sur les sauvegardes.</summary>

                <text>La commande <cmd>info</cmd> fonctionne sur un ou plusieurs stanza. La sortie texte est la valeur par défaut et donne un résumé lisible par l'utilisateur des sauvegardes pour le ou les stanza demandées.  Ce format est susceptible de changer à chaque version.

                Pour une sortie lisible par machine (programme), utiliser l'option <setting>--output=json</setting>.  La sortie JSON contient beaucoup plus d'informations que la sortie texte; elle reste stable à chaque version, à moins qu'un bogue ne soit trouvé.</text>

                <option-list>
                    <!-- OPERATION - INFO COMMAND - OUTPUT OPTION -->
                    <option id="output" name="Sortie">
                        <summary>Format de sortie.</summary>

                        <text>Les sorties suivantes sont prises en charge:
                        <ul>
                            <li><id>text</id> - Résumé des informations de sauvegarde lisible par l'utilisateur.</li>
                            <li><id>json</id> - Informations exhaustives sur les sauvegardes au format JSON à destination de machine.</li>
                        </ul></text>

                        <example>json</example>
                    </option>

                    <option id="set" name="Jeu">
                        <summary>Détail du jeu de sauvegarde.</summary>

                        <text>Les détails comportent une liste des bases de données (avec leurs OID) dans le jeu de sauvegarde (à l'exclusion des bases de données modèles), les tablespaces (avec leurs OID) avec la destination où ils seront restaurés par défaut, et les liens symboliques avec la destination où ils seront restaurés lorsque <setting>--link-all</setting> est spécifié.</text>
                        <example>20150131-153358F_20150131-153401I</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Informations pour un stanza particulier">
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db --output=json info
                        </code-block>

                        Obtenir les informations de savegarde pour le stanza <id>db</id>.</text>
                    </command-example>

                    <command-example title="Informations pour toutes les stanzas">
                        <text><code-block title="">
                            {[backrest-exe]} --output=json info
                        </code-block>

                        Obtenir les informations de sauvegardes pour tous les stanza du dépôt.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - HELP COMMAND -->
            <command id="help" name="Aide">
                <summary>Obtenir de l'aide.</summary>

                <text>Trois niveaux d'aide sont disponible. Si aucune commande n'est spécifiée, l'aide générale sera affichée. Si une commande est spécifiée, une description complète de la commande sera affichée ainsi qu'une liste des options valides, enfin si une option est spécifiée en plus de la commande, une description complète de l'option en question s'affichera.</text>

                <command-example-list>
                    <command-example title="Aide de la commande de sauvegarde">
                        <text><code-block title="">
                            {[backrest-exe]} help backup
                        </code-block>

                        Obtenir de l'aide pour la commande de sauvegarde.</text>
                    </command-example>

                    <command-example title="Aide de la commande de sauvegarde, option --force">
                        <text><code-block title="">
                            {[backrest-exe]} help backup force
                        </code-block>

                        Obtenir de l'aide pour l'option force de la commande de sauvegarde.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - START COMMAND -->
            <command id="start" name="Start">
                <summary>Autorise l'exécution des processus <backrest/>.</summary>

                <text>Si les processus <backrest/> ont été précédemment arrêtés à l'aide de la commande <cmd>stop</cmd>, ils peuvent être relancés à l'aide de la commande <cmd>start</cmd>.  Notez que cela ne démarrera pas immédiatement les processus <backrest/> mais ils seront autorisés à s'exécuter.</text>

                <command-example-list>
                    <command-example title="Démarrer les processus pour le stanza principale">
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=main start
                        </code-block>

                        Autorise l'exécution des processus <backrest/> pour le stanza <id>main</id>.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - STOP COMMAND -->
            <command id="stop" name="Stop">
                <summary>Stop <backrest/> processes from running.</summary>

                <text>Interdit l'exécution de tout nouveau processus <backrest/>. Par défaut, les processus en cours d'exécution seront autorisés à se terminer normalement. Utiliser l'option <setting>--force</setting> pour mettre fin aux processus en cours.

                Les processus <backrest/> retourneront une erreur s'ils sont exécutés après la fin de la commande d'arrêt.</text>

                <option-list>
                    <!-- OPERATION - STOP COMMAND - FORCE OPTION -->
                    <option id="force" name="Force">
                        <summary>Forcer l'arrêt de tous les processus <backrest/>.</summary>

                        <text>Cette option enverra un signal TERM à tous les processus <backrest/> en cours pour effectuer un arrêt contrôlé et immédiat.  Notez que cela arrêtera également les processus qui ont été lancés depuis un autre système et qui ont des commandes à distance fonctionnant sur le système actuel.  Par exemple, si une sauvegarde a été lancée sur le serveur de sauvegarde, l'exécution de <cmd>stop --force</cmd> sur le serveur de base de données arrêtera le processus de sauvegarde sur le serveur de sauvegarde.</text>

                        <example>y</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Arrêter les processus pour tout les stanzas">
                        <text><code-block title="">
                            {[backrest-exe]} stop
                        </code-block>

                        Arrêter les nouveaux processus <backrest/> pour tout les stanza mais permettre à tout processus en cours de se terminer.</text>
                    </command-example>
                </command-example-list>
            </command>


            <!-- OPERATION - VERSION COMMAND -->
            <command id="version" name="Version">
                <summary>Obtenir la version.</summary>

                <text>Affiche la version <backrest/> installée..</text>

                <command-example-list>
                    <command-example title="Obtenir version">
                        <text><code-block title="">
                            {[backrest-exe]} version
                        </code-block>

                        Obtenir la version de  <backrest/>.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - STANZA-CREATE COMMAND -->
            <command id="stanza-create" name="Création du Stanza">
                <summary>Create the required stanza data.</summary>

                <text>La commande <cmd>stanza-create</cmd> doit être exécutée sur l'hôte où se trouve le dépôt après que le stanza ait été configurée dans <file>pgbackrest.conf</file>.</text>

                <option-list>
                    <!-- OPERATION - STANZA-CREATE COMMAND - FORCE OPTION -->
                    <option id="force" name="Forcer">
                        <summary>Forcer la création du stanza.</summary>

                        <text>Cette option n'est plus supportée.</text>

                        <example>n</example>
                    </option>

                    <!-- ======================================================================================================= -->
                    <option id="online" name="Online">
                        <summary>Création sur une instance en ligne.</summary>

                        <text>Le fait de spécifier <br-option>--no-online</br-option> empêche <backrest/> de se connecter à <postgres/> lors de la création du stanza.</text>

                        <example>n</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Créer les données requise au stanza">
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db stanza-create
                        </code-block>

                        Créer les données requises pour le stanza <id>db</id>.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - STANZA-UPGRADE COMMAND -->
            <command id="stanza-upgrade" name="Mise à niveau du Stanza">
                <summary>Mettre à jour un stanza.</summary>

                <text>Immédiatement après la mise à niveau de <postgres/> vers une nouvelle version majeure, le chemin <br-option>pg-path</br-option> pour toute la configuration de <backrest/>  doit être défini sur le nouvel emplacement de la base de données et la commande <cmd>stanza-upgrade</cmd> doit être exécuté sur l'hôte du dépôt. Si l'instance  <postgres/> est hors ligne, utilisez l'option <br-option>--no-online</br-option>.</text>

                <option-list>
                    <!-- ======================================================================================================= -->
                    <option id="online" name="Online">
                        <summary>Mettre à jour une instance en ligne.</summary>

                        <text>Le fait de spécifier <br-option>--no-online</br-option> empêche <backrest/> de se connecter à <postgres/> lors de la mise à jour du stanza.</text>

                        <example>n</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Mise à niveau du stanza">
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db stanza-upgrade
                        </code-block>

                        Met à jour le stanza <id>db</id> avec une nouvelle version de <postgres/>.</text>
                    </command-example>
                </command-example-list>
            </command>

            <!-- OPERATION - STANZA-DELETE COMMAND -->
            <command id="stanza-delete" name="suppression du Stanza">
                <summary>Supprimer un stanza.</summary>

                <text>La commande <cmd>stanza-delete</cmd> supprime les données du dépôt associé au stanza.<admonition type="warning">Utilisez cette commande avec précaution &amp;mdash; elle supprimera définitivement toutes les sauvegardes et archives du dépôt <backrest/> pour la stanza spécifiée.</admonition>
                Pour supprimer un stanza:
                <ul>
                    <li>Arrêter l'instance <postgres/> associé au stanza (ou utiliser l'option <br-option>--force</br-option> pour passer outre).</li>
                    <li>Exécuter la commande <cmd>stop</cmd> sur l'hôte du dépôt.</li>
                    <li>Exécuter la commande <cmd>stanza-delete</cmd> sur l'hôte du dépôt.</li>
                </ul>Une fois la commande terminée avec succès, il incombe à l'utilisateur de supprimer de la configuration <backrest/> le stanza.</text>

                <option-list>
                    <!-- OPERATION - STANZA-CREATE COMMAND - FORCE OPTION -->
                    <option id="force" name="Force">
                        <summary>Forcer la suppression du stanzadu réferentiel.</summary>

                        <text>Si <postgres/> est toujours en cours d'exécution pour le stanza, alors cette option peut être utilisée pour forcer sa suppression du référentiel.</text>

                        <example>n</example>
                    </option>
                </option-list>

                <command-example-list>
                    <command-example title="Supprimer un stanza">
                        <text><code-block title="">
                            {[backrest-exe]} --stanza=db stanza-delete
                        </code-block>

                        Supprime le (stanza) <id>db</id> du référentiel.</text>
                    </command-example>
                </command-example-list>
            </command>
        </command-list>
    </operation>
</doc>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Guide de l'utilisateur pgBackRest - RHEL &amp; CentOS 7 / PostgreSQL 9.6</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta><meta property="og:site_name" content="pgBackRest - Reliable PostgreSQL Backup &amp; Restore"></meta><meta property="og:title" content="Guide de l'utilisateur pgBackRest - RHEL &amp; CentOS 7 / PostgreSQL 9.6"></meta><meta property="og:type" content="website"></meta><link rel="icon" href="favicon.png" type="image/png"></link><meta property="og:image:type" content="image/png"></meta><meta property="og:image" content="http://www.pgbackrest.org/logo.png"></meta><meta name="description" content="Le guide de l'utilisateur de pgBackRest vous montre comment configurer rapidement et facilement pgBackRest avec votre instance de base de données PostgreSQL. Des instructions pas à pas guident l'utilisateur à travers toutes les caractéristiques importantes de la solution de sauvegarde et de restauration pour PostgreSQL la plus rapide et la plus fiable."></meta><meta property="og:description" content="Le guide de l'utilisateur de pgBackRest vous montre comment configurer rapidement et facilement pgBackRest avec votre instance de base de données PostgreSQL. Des instructions pas à pas guident l'utilisateur à travers toutes les caractéristiques importantes de la solution de sauvegarde et de restauration pour PostgreSQL la plus rapide et la plus fiable."></meta><link rel="stylesheet" href="default.css" type="text/css"></link></head><body><div class="page-header"><div class="page-header-title">Guide de l'utilisateur pgBackRest</div><div class="page-header-subtitle">RHEL & CentOS 7 / PostgreSQL 9.6</div></div><div class="page-toc"><div class="page-toc-header"><div class="page-toc-title">Table of Contents</div></div><div class="page-toc-body"><div class="section1-toc"><div class="section1-toc-number">1</div><div class="section1-toc-title"><a href="#introduction">Introduction</a></div></div><div class="section1-toc"><div class="section1-toc-number">2</div><div class="section1-toc-title"><a href="#concept">Concepts</a></div><div class="section2-toc"><div class="section2-toc-number">2.1</div><div class="section2-toc-title"><a href="#concept/backup">Sauvegarde</a></div></div><div class="section2-toc"><div class="section2-toc-number">2.2</div><div class="section2-toc-title"><a href="#concept/restore">Restoration</a></div></div><div class="section2-toc"><div class="section2-toc-number">2.3</div><div class="section2-toc-title"><a href="#concept/wal">Journaux de transaction (Write Ahead Log : WAL)</a></div></div><div class="section2-toc"><div class="section2-toc-number">2.4</div><div class="section2-toc-title"><a href="#concept/encryption">Chiffrement</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">3</div><div class="section1-toc-title"><a href="#upgrading">Mise à niveau de pgBackRest</a></div><div class="section2-toc"><div class="section2-toc-number">3.1</div><div class="section2-toc-title"><a href="#upgrading/v1-v2">Mise à niveau de pgBackRest depuis la v1 vers la v2</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">4</div><div class="section1-toc-title"><a href="#build">Construction</a></div></div><div class="section1-toc"><div class="section1-toc-number">5</div><div class="section1-toc-title"><a href="#installation">Installation</a></div></div><div class="section1-toc"><div class="section1-toc-number">6</div><div class="section1-toc-title"><a href="#quickstart">Démarrage rapide</a></div><div class="section2-toc"><div class="section2-toc-number">6.1</div><div class="section2-toc-title"><a href="#quickstart/setup-demo-cluster">Mise en place de l'instance de démonstration</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.2</div><div class="section2-toc-title"><a href="#quickstart/configure-stanza">Configuration du dépots de sauvegarde (Stanza)</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.3</div><div class="section2-toc-title"><a href="#quickstart/create-repository">Création du dépot de sauvegarde</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.4</div><div class="section2-toc-title"><a href="#quickstart/configure-archiving">Configuration de l'archivage</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.5</div><div class="section2-toc-title"><a href="#quickstart/retention">Configuration de la retention</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.6</div><div class="section2-toc-title"><a href="#quickstart/configure-encryption">Configuration du chiffrement du dépôt de sauvegarde</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.7</div><div class="section2-toc-title"><a href="#quickstart/create-stanza">Création du dépot de sauvegarde (Stanza)</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.8</div><div class="section2-toc-title"><a href="#quickstart/check-configuration">Vérification de la configuration</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.9</div><div class="section2-toc-title"><a href="#quickstart/perform-backup">Effectuer une sauvegarde</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.10</div><div class="section2-toc-title"><a href="#quickstart/schedule-backup">Planifier une sauvegarde</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.11</div><div class="section2-toc-title"><a href="#quickstart/backup-info">Informations sur les sauvegardes</a></div></div><div class="section2-toc"><div class="section2-toc-number">6.12</div><div class="section2-toc-title"><a href="#quickstart/perform-restore">Restauration d'une sauvegarde</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">7</div><div class="section1-toc-title"><a href="#backup">Sauvegarde</a></div><div class="section2-toc"><div class="section2-toc-number">7.1</div><div class="section2-toc-title"><a href="#backup/option-start-fast">Option de démarrage rapide</a></div></div><div class="section2-toc"><div class="section2-toc-number">7.2</div><div class="section2-toc-title"><a href="#backup/option-archive-timeout">Timeout des archives</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">8</div><div class="section1-toc-title"><a href="#monitor">Supervision</a></div><div class="section2-toc"><div class="section2-toc-number">8.1</div><div class="section2-toc-title"><a href="#monitor/postgresql">Dans <span class="postgres">PostgreSQL</span></a></div></div></div><div class="section1-toc"><div class="section1-toc-number">9</div><div class="section1-toc-title"><a href="#retention">Rétention</a></div><div class="section2-toc"><div class="section2-toc-number">9.1</div><div class="section2-toc-title"><a href="#retention/full">Conservation de la sauvegarde complète</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.2</div><div class="section2-toc-title"><a href="#retention/diff">Rétention de la sauvegarde différentielle</a></div></div><div class="section2-toc"><div class="section2-toc-number">9.3</div><div class="section2-toc-title"><a href="#retention/archive">Rétention des archives</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">10</div><div class="section1-toc-title"><a href="#restore">Restauration</a></div><div class="section2-toc"><div class="section2-toc-number">10.1</div><div class="section2-toc-title"><a href="#restore/ownership">Propriétaire du fichier</a></div></div><div class="section2-toc"><div class="section2-toc-number">10.2</div><div class="section2-toc-title"><a href="#restore/option-delta">Option de Delta</a></div></div><div class="section2-toc"><div class="section2-toc-number">10.3</div><div class="section2-toc-title"><a href="#restore/option-db-include">Restaurer des bases de données sélectionnées</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">11</div><div class="section1-toc-title"><a href="#pitr">Point-in-Time Recovery</a></div></div><div class="section1-toc"><div class="section1-toc-number">12</div><div class="section1-toc-title"><a href="#s3-support">Support de S3-Compatible Object Store</a></div></div><div class="section1-toc"><div class="section1-toc-number">13</div><div class="section1-toc-title"><a href="#delete-stanza">Supprimer un stanza</a></div></div><div class="section1-toc"><div class="section1-toc-number">14</div><div class="section1-toc-title"><a href="#repo-host">Hote de référentiel de sauvegarde dédié</a></div><div class="section2-toc"><div class="section2-toc-number">14.1</div><div class="section2-toc-title"><a href="#repo-host/install">Installation</a></div></div><div class="section2-toc"><div class="section2-toc-number">14.2</div><div class="section2-toc-title"><a href="#repo-host/setup-ssh">Configuration de SSH par échange de clés</a></div></div><div class="section2-toc"><div class="section2-toc-number">14.3</div><div class="section2-toc-title"><a href="#repo-host/config">Configuration</a></div></div><div class="section2-toc"><div class="section2-toc-number">14.4</div><div class="section2-toc-title"><a href="#repo-host/perform-backup">Effectuer une sauvegarde</a></div></div><div class="section2-toc"><div class="section2-toc-number">14.5</div><div class="section2-toc-title"><a href="#repo-host/perform-restore">Restauration d'une sauvegarde</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">15</div><div class="section1-toc-title"><a href="#parallel-backup-restore">Sauvegarde / Restauration en parallèle</a></div></div><div class="section1-toc"><div class="section1-toc-number">16</div><div class="section1-toc-title"><a href="#start-stop">Démarrer et arrêter</a></div></div><div class="section1-toc"><div class="section1-toc-number">17</div><div class="section1-toc-title"><a href="#replication">Replication</a></div><div class="section2-toc"><div class="section2-toc-number">17.1</div><div class="section2-toc-title"><a href="#replication/installation">Installation</a></div></div><div class="section2-toc"><div class="section2-toc-number">17.2</div><div class="section2-toc-title"><a href="#replication/setup-ssh">Configurer un accès SSH sans mot de passe</a></div></div><div class="section2-toc"><div class="section2-toc-number">17.3</div><div class="section2-toc-title"><a href="#replication/hot-standby">Hot Standby</a></div></div><div class="section2-toc"><div class="section2-toc-number">17.4</div><div class="section2-toc-title"><a href="#replication/streaming">Réplication en flux contrinu flux (streaming replication)</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">18</div><div class="section1-toc-title"><a href="#async-archiving">Archivage asynchrone</a></div><div class="section2-toc"><div class="section2-toc-number">18.1</div><div class="section2-toc-title"><a href="#async-archiving/async-archive-push">Poussez les archives (Archive Push)</a></div></div><div class="section2-toc"><div class="section2-toc-number">18.2</div><div class="section2-toc-title"><a href="#async-archiving/async-archive-get">Obtention des archives (archive-get)</a></div></div></div><div class="section1-toc"><div class="section1-toc-number">19</div><div class="section1-toc-title"><a href="#standby-backup">Sauvegarde depuis l'esclave (standby)</a></div></div><div class="section1-toc"><div class="section1-toc-number">20</div><div class="section1-toc-title"><a href="#upgrade-stanza">Mise à niveau de <span class="postgres">PostgreSQL</span></a></div></div></div></div><div class="page-body"><div class="section1"><a id="introduction"></a><div class="section1-header"><div class="section1-number">1</div><div class="section1-title">Introduction</div></div><div class="section-body"><div class="section-body-text">Ce guide d'utilisateur est destiné à être suivi séquentiellement du début à la fin&mdash; chaque section dépend de la précédente. Par exemple, la section <a href="#backup">Backup</a> repose sur la configuration qui est décrite dans la sesction <a href="#quickstart">Démarrage rapide</a>. Une fois que la configuration de <span class="backrest">pgBackRest</span> est opérationnelle, il est possible de sauter des étapes, mais il est recomandé de suivre le guide dans l'ordre la première fois.</div><div class="section-body-text">Bien que les exemples soient destinées pour être mise en oeuvre avec le système d'exploitation RHEL/CentOS 7 et <span class="postgres">PostgreSQL</span> version 9.6, il devrait être assez simple d'appliquer ce guide à toute autre distribution Unix et à toutes les versions de <span class="postgres">PostgreSQL</span>. Seules les commandes spécifiques au système d'exploitation sont celle qui permettent de créer, de démarrer, d'arrêter et de détruire une instance <span class="postgres">PostgreSQL</span>. Les commandes de <span class="backrest">pgBackRest</span> seront les mêmes quelques soit le syst-me Unix que vous utilisez&mdash; bien entendue les emplacement d'installation des excutables peuvent varier.<br/>
<br/>
Les informations et la documentation relatives à la configuration d'une instance <span class="postgres">PostgreSQL</span> se trouvent sur les sites <a href="http://www.postgresql.org/docs/9.6/static/index.html">Manuel en Anglais officiel</a> ou pour la version française <a href="http://www.postgresqlfr.org/docs/9.6/static/index.html">sur le site d'association PostgreSQLfr</a>.</div><div class="section-body-text">Le présent guide de l'utilisateur adopte une approche assez nouvelle dans la rédaction de la documentation. En effet chaque comande est exécutée sur une machine virtuelle lorsque la documentation est rédigé de façon automatique à partir de la source au format XML. Cela signifie que vous pouvez avoir la certitude que les commandes fonctionnent correctement dans l'ordre qui vous sera présenté. Les résultats de chaque commande sont capturés et affichés sous celle-ci. Si la sortie n'est pas incluse, c'est qu'elle a été jugée non pertinente.</div><div class="section-body-text">Toutes les commandes sont destinées à être exécutées par un utilisateur non privilégié qui dispose du droit sudo pour les utilisateurs <span class="user">root</span> et <span class="user">postgres</span>. Il est possible d'exécuter les commandes directement en tant que l'utilisateurs <span class="user">root</span> et <span class="user">postgres</span>&mdash; dans ce cas, les commandes <span class="cmd">sudo</span> peuvent être retirées.</div></div></div><div class="section1"><a id="concept"></a><div class="section1-header"><div class="section1-number">2</div><div class="section1-title">Concepts</div></div><div class="section-body"><div class="section-body-text">La notion des concepts suivants sont définis comme étant pertients dans la compréhention de <span class="backrest">pgBackRest</span>, <span class="postgres">PostgreSQL</span>, et de ce guide de l'utilisateur.</div><div class="section2"><a id="concept/backup"></a><div class="section2-header"><div class="section2-number">2.1</div><div class="section2-title">Sauvegarde</div></div><div class="section-body"><div class="section-body-text">Une sauvegarde est une copie cohérente d'une instance de base de données qui peut être restauré suite à une panne matérielle, pour effectuer une récupération à un instant (PITR) ou encore pour créer une nouvelle instance esclave.</div><div class="section-body-text"><b>Sauvegarde complète</b>: <span class="backrest">pgBackRest</span> copie l'intégralité du contenu de l'instance de base de données sur la sauvegarde. La première sauvegarde d'une instance est toujours une sauvegarde complète. <span class="backrest">pgBackRest</span> sera toujours capable de restaurer directement une sauvegarde complète. Cette sauvegarde complète ne dépent d'aucun autre fichier en dehors de la sauvegarde complète, ceci pour des raisons de consistance.</div><div class="section-body-text"><b>Sauvegarde différentielle</b>: <span class="backrest">pgBackRest</span> ne copie que les fichiers de l'instance ayant changé depuis la dernière sauvegarde complète. Lors d'une restauration dfférentielle <span class="backrest">pgBackRest</span> restaure en copiant tous les fichiers de la sauvegarde différentielle ainsi que les fichiers inchangé de la précédente sauvegarde complète. L'avantage d'une sauvegarde différentielle est qu'elle nécessite moins d'espace disque qu'une sauvegarde complète. Cependant, la sauvegarde différentielle et la sauvegarde complète doivent toutes deux être valides pour restaurer la sauvegarde différentielle.</div><div class="section-body-text"><b>Sauvegarde incrémentale</b>: <span class="backrest">pgBackRest</span> ne copie que les fichiers de l'instance de base de données qui ont été modifiés depuis la dernière sauvegarde (celle-ci peut être une autre sauvegarde incrémentale, une sauvegarde différentielle ou une sauvegarde complète). Puisqu'une sauvegarde incrémentale n'inclut que les fichiers modifiés depuis la sauvegarde précédente, ils sont généralement beaucoup plus petits que les sauvegardes complètes ou différentielles. Comme pour la sauvegarde différentielle, la sauvegarde incrémentale dépend des autres sauvegardes pour pouvoir être restaurer. Etant donné que la sauvegarde incrémentale ne comprend que les fichiers modifiés depuis la dernière sauvegarde, toutes les sauvegardes incrémentale antérieures qui ont été effectuées ainsi que la sauvegarde différentielle antérieure et la sauvegarde complète antérieure doivent toutes être valides pour pouvoir effectuer une restauration de la sauvegarde incrémentale. Si aucune sauvegarde différentielle n'existe, alors toutes les sauvegardes incrémentales antérieures doivent être valide depuis la dernière sauvegarde complète pour pouvoir restaurer la sauvegarde incrémentale.</div></div></div><div class="section2"><a id="concept/restore"></a><div class="section2-header"><div class="section2-number">2.2</div><div class="section2-title">Restoration</div></div><div class="section-body"><div class="section-body-text">Une restauration est une opération qui consiste à copier une sauvegarde sur un système pour être lancer en temps qu'instance de base de données. Une restauration nécessite les fichiers de sauvegarde et un ou plusieurs segments WAL (journaux de transaction) afin de fonctionner correctement.</div></div></div><div class="section2"><a id="concept/wal"></a><div class="section2-header"><div class="section2-number">2.3</div><div class="section2-title">Journaux de transaction (Write Ahead Log : WAL)</div></div><div class="section-body"><div class="section-body-text">Le WAL est le mécanisme que <span class="postgres">PostgreSQL</span> utilise pour s'assurer qu'aucun changement confirmé n'est perdu. Les transactions sont écrites séquentiellement dans le WAL et une transaction est considérée comme confirmée lorsque ces écritures sont enregistrées sur le disque. Ensuite, un processus en arrière-plan écrit les modifications dans les fichiers principaux de l'instance de la base de données (également connu sous le nom <q>heap</q>). En cas de crash, le WAL est rejoué pour rendre la base de données cohérente.</div><div class="section-body-text">Le WAL est conceptuellement infini mais en pratique, il est divisé en fichiers individuels de 16 Mo appelés segments. Les segments WAL suivent la convention de nommage suivant <span class="id">0000000100000A1E000000FE</span> où les 8 premiers chiffres hexadécimaux représentent la 'timeline' et les 16 chiffres suivants sont le numéro de séquence logique (LSN).</div></div></div><div class="section2"><a id="concept/encryption"></a><div class="section2-header"><div class="section2-number">2.4</div><div class="section2-title">Chiffrement</div></div><div class="section-body"><div class="section-body-text">Le chiffrement est le processus de conversion des données dans un format qui n'est pas reconnaissable à moins que le mot de passe approprié (également appelé clef) ne soit fourni.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> chiffrera le dépôt de sauvegarde sur la base d'un mot de passe fourni par l'utilisateur, empêchant ainsi tout accès non autorisé aux données stockées dans le dépôt.</div></div></div></div></div><div class="section1"><a id="upgrading"></a><div class="section1-header"><div class="section1-number">3</div><div class="section1-title">Mise à niveau de pgBackRest</div></div><div class="section-body"><div class="section2"><a id="upgrading/v1-v2"></a><div class="section2-header"><div class="section2-number">3.1</div><div class="section2-title">Mise à niveau de pgBackRest depuis la v1 vers la v2</div></div><div class="section-body"><div class="section-body-text">Le passage de la version <span class="host">v1</span> vers la version <span class="host">v2</span> est assez simple. Le format du dépôt de sauvegarde n'a pas changé et les options marqué comme dépréciées de la <span class="host">v1</span> reste acceptées de sorte que pour la plupart des installations, une simple mise à jours des binaires vers la nouvelle version suffit.</div><div class="section-body-text">Toutefois, il y a quelques mises en garde :</div><ul class="list-unordered"><li class="list-unordered">L'option dépréciées <span class="br-option">thread-max</span> n'est plus valide. Utiliser <span class="br-option">process-max</span> à la place.</li><li class="list-unordered">L'option dépréciées <span class="br-option">archive-max-mb</span> n'est plus valide. Cette option a été remplacée par l'option <span class="br-option">archive-push-queue-max</span> qui a une syntaxe différente.</li><li class="list-unordered">La valeur par defaut pour l'option <span class="br-option">backup-user</span> est passée de <span class="id">backrest</span> à <span class="id">pgbackrest</span>.</li><li class="list-unordered">Dans la version <span class="host">v2.02</span> l'emplacement par défaut du fichier de configuration de <span class="backrest">pgBackRest</span> a changé de <span class="file">/etc/pgbackrest.conf</span> à <span class="file">/etc/pgbackrest/pgbackrest.conf</span>. Si le fichier <span class="file">/etc/pgbackrest/pgbackrest.conf</span> n'existe pas alors le fichier <span class="file">/etc/pgbackrest.conf</span> sera chargé à la place, s'il existe.</li></ul><div class="section-body-text">De nombreux noms d'options ont été modifiés pour améliorer la cohérence, bien que les anciens noms de la version <span class="host">v1</span> soient toujours acceptés. De manière générale, les options <span class="id">db-*</span> ont été renommées en <span class="id">pg-*</span> et les options <span class="id">backup-*</span>/<span class="id">retention-*</span> ont été renommées en <span class="id">repo-*</span> lorsque que celà été approprié.</div><div class="section-body-text">Les options de <span class="postgres">PostgreSQL</span> et du dépot de sauvegarde doivent être référencées lors de l'utilisation des nouveaux noms introduit par la version <span class="host">v2</span>, (par exemple pour les options <span class="br-option">pg1-host</span>, <span class="br-option">pg1-path</span>, <span class="br-option">repo1-path</span>, <span class="br-option">repo1-type</span>, etc.). Un seul dépôt est autorisé actuellement mais une plus grande flexibilité est prévue pour la version <span class="host">v2</span>.</div></div></div></div></div><div class="section1"><a id="build"></a><div class="section1-header"><div class="section1-number">4</div><div class="section1-title">Construction</div></div><div class="section-body"><div class="section-body-text">RHEL/CentOS 7 packages for <span class="backrest">pgBackRest</span> are available from <a href="http://www.crunchydata.com">Crunchy Data</a> or <a href="http://yum.postgresql.org">yum.postgresql.org</a>, but it is also easy to download the source and install manually.</div><div class="section-body-text">Lorsque l'on construit à partir des sources, il est préférable d'utiliser un système dédié à la construction plutôt que de le faire sur votre environnement de production. La plupart des outils nécessaires à la construction ne doivent généralement pas être installés sur un environnement de production. <span class="backrest">pgBackRest</span> est composé d'un seul exécutable, il est donc facile de le copier vers votre enironnement de produition une fois construit.</div><div class="execute"><div class="execute-title"><span class="host">build</span> <b>&#x21d2;</b> Télécharger la version <span class="id">2.25</span> de <span class="backrest">pgBackRest</span> et extraire dans le répertoire de construction <span class="path">/build</span></div><div class="execute-body"><pre class="execute-body-cmd">wget -q -O - \
       https://github.com/pgbackrest/pgbackrest/archive/release/2.25.tar.gz | \
       tar zx -C /build</pre></div></div><div class="execute"><div class="execute-title"><span class="host">build</span> <b>&#x21d2;</b> Installation et construction les dépendances</div><div class="execute-body"><pre class="execute-body-cmd">sudo yum install make gcc postgresql-devel openssl-devel libxml2-devel lz4-devel</pre></div></div><div class="execute"><div class="execute-title"><span class="host">build</span> <b>&#x21d2;</b> Configuration et compilation de <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">cd /build/pgbackrest-release-2.25/src &amp;&amp; ./configure &amp;&amp; make</pre></div></div></div></div><div class="section1"><a id="installation"></a><div class="section1-header"><div class="section1-number">5</div><div class="section1-title">Installation</div></div><div class="section-body"><div class="section-body-text">Un nouvel hôte nommé <span class="host">pg1</span> est créé pour contenir l'instance de démonstration afin d'executer les exemples de <span class="backrest">pgBackRest</span>.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> doit être installé à partir d'un paquet ou installé manuellement comme indiqué ci-dessous.</div><div class="execute"><div class="execute-title"><span class="host">build</span> <b>&#x21d2;</b> Installation des dépendances</div><div class="execute-body"><pre class="execute-body-cmd">sudo yum install postgresql-libs</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Copiez les binaires de <span class="backrest">pgBackRest</span> depuis la plateforme de compilation</div><div class="execute-body"><pre class="execute-body-cmd">sudo scp build:/build/pgbackrest-release-2.25/src/pgbackrest /usr/bin</pre><pre class="execute-body-cmd">sudo chmod 755 /usr/bin/pgbackrest</pre></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> nécessite des répertoires pour les traces (logs) et pour la configuration ainsi qu'un fichier de configuration.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création des répertoires et du fichier de configuration pour <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p -m 770 /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -p /etc/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -p /etc/pgbackrest/conf.d</pre><pre class="execute-body-cmd">sudo touch /etc/pgbackrest/pgbackrest.conf</pre><pre class="execute-body-cmd">sudo chmod 640 /etc/pgbackrest/pgbackrest.conf</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /etc/pgbackrest/pgbackrest.conf</pre></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> devrait maintenant être correctement installé, mais il est préférable de le vérifier. Si des dépendances ont été omises, vous obtiendrez une erreur lorsque vous lancerez <span class="backrest">pgBackRest</span> à partir de la ligne de commande.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> S'assurer que l'installation a fonctionné</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest</pre><pre class="execute-body-output">pgBackRest 2.25 - General help

Usage:
    pgbackrest [options] [command]

Commands:
    archive-get     Get a WAL segment from the archive.
    archive-push    Push a WAL segment to the archive.
    backup          Backup a database cluster.
    check           Check the configuration.
    expire          Expire backups that exceed retention.
    help            Get help.
    info            Retrieve information about backups.
    restore         Restore a database cluster.
    stanza-create   Create the required stanza data.
    stanza-delete   Delete a stanza.
    stanza-upgrade  Upgrade a stanza.
    start           Allow pgBackRest processes to run.
    stop            Stop pgBackRest processes from running.
    version         Get version.

Use 'pgbackrest help [command]' for more information.</pre></div></div></div></div><div class="section1"><a id="quickstart"></a><div class="section1-header"><div class="section1-number">6</div><div class="section1-title">Démarrage rapide</div></div><div class="section-body"><div class="section-body-text">La section Démarrage rapide couvre la configuration de base de <span class="backrest">pgBackRest</span> et <span class="postgres">PostgreSQL</span>. Elle présente les commandes <span class="cmd">backup</span>, <span class="cmd">restore</span>, et <span class="cmd">info</span>.</div><div class="section2"><a id="quickstart/setup-demo-cluster"></a><div class="section2-header"><div class="section2-number">6.1</div><div class="section2-title">Mise en place de l'instance de démonstration</div></div><div class="section-body"><div class="section-body-text">La création de l'instance de démonstration est facultative mais fortement recommandée, en particulier pour les nouveaux utilisateurs. Les exemples de commande de ce guide font référence à cette instance de démonstration; les exemples sont fonctionnel sur une instance fonctionnant sur le port d'écoute par defaut (c'est-à-dire le port 5432). L'instance ne sera pas encore lancé, car il reste des actions de configuration à réaliser qui seront décrites dans la section suivante.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création de l'instance de démonstation</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres /usr/pgsql-9.6/bin/initdb \
       -D /var/lib/pgsql/9.6/data -k -A peer</pre></div></div><div class="section-body-text">Par défaut, <span class="postgres">PostgreSQL</span> n'accepte que les connexions locales. Les exemples présentés dans ce guide nécessiteront des connexions à partir d'autres serveurs ce qui implique de modifier le paramètre <span class="pg-option">listen_addresses</span> pour écouter sur toutes les interfaces. Ceci n'est peut être pas approprié pour les installations sécurisées.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/var/lib/pgsql/9.6/data/postgresql.conf</span> <b>&#x21d2;</b> Modification <span class="pg-option">listen_addresses</span></div><div class="config-body"><div class="config-body-output">listen_addresses = '*'</div></div></div><div class="section-body-text">À des fins de démonstration, le paramètre <span class="pg-option">log_line_prefix</span> sera configuré au minimum. Cela permet de garder la sortie du journal aussi brève que possible pour mieux illustrer les informations importantes.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/var/lib/pgsql/9.6/data/postgresql.conf</span> <b>&#x21d2;</b> Modification de <span class="pg-option">log_line_prefix</span></div><div class="config-body"><div class="config-body-output">listen_addresses = '*'<br/>
log_line_prefix = ''</div></div></div><div class="section-body-text">Par défaut sur RHEL/CentOS 7 le nom du fichier de journalisation des traces inclus le nom du jour de la semaine. Cela rend l'automatisation du guide de l'utilisateur un peu plus compliquée, le paramètre <span class="pg-option">log_filename</span> est donc fixée à une constante.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/var/lib/pgsql/9.6/data/postgresql.conf</span> <b>&#x21d2;</b> Modification <span class="pg-option">log_filename</span></div><div class="config-body"><div class="config-body-output">listen_addresses = '*'<br/>
log_filename = 'postgresql.log'<br/>
log_line_prefix = ''</div></div></div></div></div><div class="section2"><a id="quickstart/configure-stanza"></a><div class="section2-header"><div class="section2-number">6.2</div><div class="section2-title">Configuration du dépots de sauvegarde (Stanza)</div></div><div class="section-body"><div class="section-body-text">A stanza is the configuration for a <span class="postgres">PostgreSQL</span> database cluster that defines where it is located, how it will be backed up, archiving options, etc. Most db servers will only have one Postgres database cluster and therefore one stanza, whereas backup servers will have a stanza for every database cluster that needs to be backed up.<br/>
<br/>
It is tempting to name the stanza after the primary cluster but a better name describes the databases contained in the cluster. Because the stanza name will be used for the primary and all replicas it is more appropriate to choose a name that describes the actual function of the cluster, such as app or dw, rather than the local cluster name, such as main or prod.</div><div class="section-body-text">Le nom 'demo' décrit assez bien l'objectif du dépot de données de sauvegarde (stanza). Ce qui en fera également un bon nom pour notre 'stanza'.</div><div class="section-body-text"><span class="backrest">pgBackRest</span>doit savoir où se trouve le répertoire des données de base de l'instance <span class="postgres">PostgreSQL</span>. Le chemin peut être directement obtenu auprès de <span class="postgres">PostgreSQL</span> mais dans un scénario de restauration, le processus <span class="postgres">PostgreSQL</span> ne sera pas disponible. Lors des sauvegardes, la valeur fournie à <span class="backrest">pgBackRest</span> sera comparée au chemin sur lequel <span class="postgres">PostgreSQL</span> est exécuté; ils doivent être égaux sinon la sauvegarde retournera une erreur. Assurez-vous que le parmaètre <span class="br-option">pg-path</span> soit strictement égal au parmaètre <span class="pg-option">data_directory</span> du fichier <span class="file">postgresql.conf</span>.</div><div class="section-body-text">Par défaut sur RHEL/CentOS 7 le répertoire de l'instance est <span class="path">/var/lib/pgsql/[version]/data</span> afin de déterminer facilement le chemin correct du repertoire de données.</div><div class="section-body-text">Lors de la création du fichier <span class="file">/etc/pgbackrest/pgbackrest.conf</span> le propriétaire de la base de données (généralement <span class="id">postgres</span>) doit se voir accorder les privilèges de lecture.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration du réprtoire de donnée de <span class="postgres">PostgreSQL</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data</div></div></div><div class="section-body-text">Led fichiers de configuration de <span class="backrest">pgBackRest</span> suivent la convention Windows INI. Les sections sont indiquées par du texte entre parenthèses et des paires clé/valeur sont contenues dans chaque section. Les lignes commençant par <span class="id">#</span> sont ignorées et peuvent être utilisées comme commentaires.</div><div class="section-body-text">Les fichiers de configuration de <span class="backrest">pgBackRest</span> peuvent être chargés de plusieurs façons :</div><ul class="list-unordered"><li class="list-unordered"><span class="br-option">config</span> et <span class="br-option">config-include-path</span> sont par défaut : le fichier de configuration par défaut sera chargé, s'il existe, et les fichiers <span class="file">*.conf</span> dans le chemin d'inclusion de la configuration par défaut seront ajoutés, s'ils existent.</li><li class="list-unordered">Lorsque l'option <span class="br-option">config</span> est spécifiée : seul le fichier de configuration spécifié sera chargé et il devra exister.</li><li class="list-unordered">Lorsque l'option <span class="br-option">config-include-path</span> est spécifiée : Les fichiers <span class="file">*.conf</span> dans le chemin d'inclusion de la configuration seront chargés et le chemin doit exister. Le fichier de configuration par défaut sera chargé s'il existe. Dans le cas où vous souhaitez ne charge que les fichiers du chemin d'inclusion alors l'option <span class="br-option">--no-config</span> peut être ajoutée.</li><li class="list-unordered">Lorsque l'option <span class="br-option">config</span> est <span class="br-option">config-include-path</span> sont spécifiées en utilisant les valeurs spécifiées par l'utilisateur, le fichier de configuration sera chargé et les fichiers <span class="file">*.conf</span> du chemin d'inclusion de la configuration seront ajoutés. Les. Les fichiers doivent exister.</li><li class="list-unordered">Lorsque l'option <span class="br-option">config-path</span> est spécifié : ce paramètre remplacera le chemin de base pour l'emplacement par défaut du fichier de configuration et/ou le chemin de base du paramètre <span class="br-option">config-include-path</span> par défaut, à moins que l'option <span class="br-option">config</span> et/ou <span class="br-option">config-include-path</span> ne soit explicitement définie.</li></ul><div class="section-body-text">Les fichiers sont concaténés comme s'il s'agissait d'un seul gros fichier ; 'ordre n'a pas d'importance, mais il y a une règle de classement basée sur les sections. is precedence based on sections. Ce classement est le suivant (du plus haut vers le plus bas) :</div><ul class="list-unordered"><li class="list-unordered">[<i>stanza</i>:<i>command</i>]</li><li class="list-unordered">[<i>stanza</i>]</li><li class="list-unordered">[global:<i>command</i>]</li><li class="list-unordered">[global]</li></ul><div class="admonition"><div class="note">NOTE:</div><div class="note-text">Les paramètres <span class="br-option">--config</span>, <span class="br-option">--config-include-path</span> et <span class="br-option">--config-path</span> ne sont disponible qu'à partir de la ligne de commande.</div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> peut également être configuré à l'aide de variables d'environnement comme décrit dans le document <a href="command.html">référentiel de commandes</a>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Configuration de <span class="br-option">log-path</span> en utilisant les variables d'environnement</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres bash -c ' \
       export PGBACKREST_LOG_PATH=/path/set/by/env &amp;&amp; \
       pgbackrest --log-level-console=error help backup log-path'</pre><pre class="execute-body-output">pgBackRest 2.25 - 'backup' command - 'log-path' option help

Path where log files are stored.

The log path provides a location for pgBackRest to store log files. Note that
if log-level-file=off then no log path is required.
</pre><pre class="execute-body-output-highlight">current: /path/set/by/env</pre><pre class="execute-body-output">default: /var/log/pgbackrest</pre></div></div></div></div><div class="section2"><a id="quickstart/create-repository"></a><div class="section2-header"><div class="section2-number">6.3</div><div class="section2-title">Création du dépot de sauvegarde</div></div><div class="section-body"><div class="section-body-text">The repository is where <span class="backrest">pgBackRest</span> stores backups and archives WAL segments.<br/>
<br/>
It may be difficult to estimate in advance how much space you'll need. The best thing to do is take some backups then record the size of different types of backups (full/incr/diff) and measure the amount of WAL generated per day. This will give you a general idea of how much space you'll need, though of course requirements will likely change over time as your database evolves.</div><div class="section-body-text">Pour cette démonstration, le dépôt sera stocké sur le même hôte que le serveur de l'instance <span class="postgres">PostgreSQL</span>. Cette configuration est la plus simple et est utile dans les cas où un logiciel de sauvegarde traditionnel est utilisé pour sauvegarder l'hôte de la base de données.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création du dépot de sauvegarde pour <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p /var/lib/pgbackrest</pre><pre class="execute-body-cmd">sudo chmod 750 /var/lib/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/lib/pgbackrest</pre></div></div><div class="section-body-text">Le chemin du dépôt doit être configuré de telle sorte pour que <span class="backrest">pgBackRest</span> sache où le trouver.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de répertoire du dépots de sauvegarde de <span class="backrest">pgBackRest</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-path=/var/lib/pgbackrest</div></div></div></div></div><div class="section2"><a id="quickstart/configure-archiving"></a><div class="section2-header"><div class="section2-number">6.4</div><div class="section2-title">Configuration de l'archivage</div></div><div class="section-body"><div class="section-body-text">La sauvegarde d'une instance de <span class="postgres">PostgreSQL</span> requiert que l'archivage des journaux de transaction (WAL) soit activé. Notez qu'au moins un segment de WAL sera créé pendant le processus de sauvegarde et ceux même si aucune écriture explicite n'est effectuée sur votre instance.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/var/lib/pgsql/9.6/data/postgresql.conf</span> <b>&#x21d2;</b> Configuration des paramètres d'archivage</div><div class="config-body"><div class="config-body-output">archive_command = 'pgbackrest --stanza=demo archive-push %p'<br/>
archive_mode = on<br/>
listen_addresses = '*'<br/>
log_filename = 'postgresql.log'<br/>
log_line_prefix = ''<br/>
max_wal_senders = 3<br/>
wal_level = replica</div></div></div><div class="section-body-text">Régler le paramètre <span class="pg-option">wal_level</span> sur le niveau au minimum la valeur <span class="pg-setting">replica</span> et augmenter la valeur de <span class="pg-option">max_wal_senders</span> est une bonne pratique, puisque celà vous permettra d'ajouter plus tard des esclaves sans pour autant devoir redémarrer votre instance principale.</div><div class="section-body-text">L'instance <span class="postgres">PostgreSQL</span> doit être redémarré après avoir effectué ces modifications et avant d'effectuer une sauvegarde.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Redémarrage de l'instance demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl restart postgresql-9.6.service</pre></div></div><div class="section-body-text">Lorsque l'archivage d'un segment du journal de transaction (WAL) est censé prendre plus de 60 secondes (par défaut) pour atteindre le dépôt de sauvegarde de <span class="backrest">pgBackRest</span>, le paramètre <span class="br-option">archive-timeout</span> de la configuration de <span class="backrest">pgBackRest</span> doit être augmenté. Notez bien que ce paramètre n'est pas le même que celui présent dans la configuration de <span class="postgres">PostgreSQL</span> : <span class="pg-option">archive_timeout</span>, qui lui permet de forcer le changement d'un segment du journal de transaction (WAL) afin de forcer un archivage. Ceci est utile sur les bases de données ayant de longue périodes d'inactivité en écriture. Pour plus d'information concernant l'option <span class="pg-option">archive_timeout</span> de <span class="postgres">PostgreSQL</span> , consultez la documentation <span class="postgres">PostgreSQL</span> <a href="https://docs.postgresql.fr/current/runtime-config-wal.html">Write Ahead Log</a>.</div><div class="section-body-text">La commande <span class="cmd">archive-push</span> peut être configurée avec ses propres options. Par exemple, un niveau de compression inférieur peut être défini pour accélérer l'archivage des WAL sans affecter la compression utilisée pour les sauvegardes.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="cmd">archive-push</span> afin d'utiliser un niveau de compression inférieur</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-path=/var/lib/pgbackrest<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="section-body-text">Cette technique de configuration peut être utilisée pour n'importe quelle commande et peut même cibler un 'stanza' spécifique, exemple : <span class="id">demo:archive-push</span>.</div></div></div><div class="section2"><a id="quickstart/retention"></a><div class="section2-header"><div class="section2-number">6.5</div><div class="section2-title">Configuration de la retention</div></div><div class="section-body"><div class="section-body-text">L'expiration des sauvagarde <span class="backrest">pgBackRest</span> se base sur les options de rétention.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configurer la rétention à 2 sauvegardes complètes</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="section-body-text">Pour plus d'informations sur la rétention, voir la section sur la <a href="#retention">Retention</a>.</div></div></div><div class="section2"><a id="quickstart/configure-encryption"></a><div class="section2-header"><div class="section2-number">6.6</div><div class="section2-title">Configuration du chiffrement du dépôt de sauvegarde</div></div><div class="section-body"><div class="section-body-text">Le dépôt de sauvegarde sera configuré avec un type de chiffrement (cipher) et une clé. Le chiffrement est toujours effectué côté client même si le type de dépôt (par exemple <span class="host">S3</span> ou autre magasin d'objets) prend en charge le chiffrement.</div><div class="section-body-text">Il est important d'utiliser une phrase de chiffrement longue et aléatoire pour la clé de chiffrement. Une bonne façon d'en générer une est d'exécuter la commande : <span class="id">openssl rand -base64 48</span>.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration du dépot de sauvegarde chiffré <span class="backrest">pgBackRest</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-cipher-pass=zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO<br/>
repo1-cipher-type=aes-256-cbc<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="section-body-text">Une fois que le dépôt de sauvegarde a été configuré et que celui-ci a été créée et vérifiée, les paramètres de chiffrement du dépôt ne peuvent plus être modifiés.</div></div></div><div class="section2"><a id="quickstart/create-stanza"></a><div class="section2-header"><div class="section2-number">6.7</div><div class="section2-title">Création du dépot de sauvegarde (Stanza)</div></div><div class="section-body"><div class="section-body-text">La commande <span class="cmd">stanza-create</span> doit être exécutée sur l'hôte où se trouve le dépôt pour initialiser le dépot de sauvegarde. Il est recommandé d'exécuter la commande <span class="cmd">check</span> après avoir exécuté <span class="cmd">stanza-create</span> pour s'assurer que l'archivage et les sauvegardes sont correctement configurés.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création du dépot de sauvegarde et configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info stanza-create</pre><pre class="execute-body-output">P00   INFO: stanza-create command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: stanza-create command end: completed successfully</pre></div></div></div></div><div class="section2"><a id="quickstart/check-configuration"></a><div class="section2-header"><div class="section2-number">6.8</div><div class="section2-title">Vérification de la configuration</div></div><div class="section-body"><div class="section-body-text">The <span class="cmd">check</span> command validates that <span class="backrest">pgBackRest</span> and the <span class="pg-setting">archive_command</span> setting are configured correctly for archiving and backups. It detects misconfigurations, particularly in archiving, that result in incomplete backups because required WAL segments did not reach the archive. The command can be run on the database or the repository host. The command may also be run on the standby host, however, since <span class="id">pg_switch_xlog()</span>/<span class="id">pg_switch_wal()</span> cannot be performed on the standby, the command will only test the repository configuration.<br/>
<br/>
Note that <span class="id">pg_create_restore_point('pgBackRest Archive Check')</span> and <span class="id">pg_switch_xlog()</span>/<span class="id">pg_switch_wal()</span> are called to force <span class="postgres">PostgreSQL</span> to archive a WAL segment. Restore points are only supported in <span class="postgres">PostgreSQL</span> >= 9.1 so for older versions the <span class="cmd">check</span> command may fail if there has been no write activity since the last log rotation, therefore it is recommended that activity be generated by the user if there have been no writes since the last WAL switch before running the <span class="cmd">check</span> command.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Vérification de la configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info check</pre><pre class="execute-body-output">P00   INFO: check command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: WAL segment 000000010000000000000001 successfully archived to '/var/lib/pgbackrest/archive/demo/9.6-1/0000000100000000/000000010000000000000001-d3634fd7050c1d8354e13b49e932d9d1d917e722.gz'</pre><pre class="execute-body-output">P00   INFO: check command end: completed successfully</pre></div></div></div></div><div class="section2"><a id="quickstart/perform-backup"></a><div class="section2-header"><div class="section2-number">6.9</div><div class="section2-title">Effectuer une sauvegarde</div></div><div class="section-body"><div class="section-body-text">Pour effectuer une sauvegarde de l'instance <span class="postgres">PostgreSQL</span>, lancez <span class="backrest">pgBackRest</span> avec la commande <span class="cmd">backup</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> sauvegarde de l'instance demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo \
       --log-level-console=info backup</pre><pre class="execute-body-output">P00   INFO: backup command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00   WARN: no prior backup exists, incr backup has been changed to full</pre><pre class="execute-body-output">P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the next regular checkpoint completes
P00   INFO: backup start archive = 000000010000000000000002, lsn = 0/2000028
       [filtered 864 lines of output]
P01   INFO: backup file /var/lib/pgsql/9.6/data/base/1/12312 (0B, 100%)
P01   INFO: backup file /var/lib/pgsql/9.6/data/base/1/12307 (0B, 100%)</pre><pre class="execute-body-output-highlight">P00   INFO: full backup size = 21MB</pre><pre class="execute-body-output">P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000002, lsn = 0/2000130
       [filtered 5 lines of output]</pre></div></div><div class="section-body-text">Par défaut, <span class="backrest">pgBackRest</span> tentera d'effectuer une sauvegarde incrémentielle. Cependant, une sauvegarde incrémentielle doit être basée sur une sauvegarde complète et comme il n'y a pas de sauvegarde complète, <span class="backrest">pgBackRest</span> effectue une sauvegarde complète à la place.</div><div class="section-body-text">L'option <span class="br-option">type</span> peut être utilisée pour spécifier une sauvegarde complète ou différentielle.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Sauvegarde différentielle de l'instance demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 4 lines of output]
P01   INFO: backup file /var/lib/pgsql/9.6/data/global/pg_control (8KB, 89%) checksum 6ddf36366ec3353478f1fd51f3577a22e786b424
P01   INFO: backup file /var/lib/pgsql/9.6/data/pg_log/postgresql.log (1010B, 100%) checksum 916b419ec1434c0d3521f0b29ee2cc35f9105bbf</pre><pre class="execute-body-output-highlight">P00   INFO: diff backup size = 9.0KB</pre><pre class="execute-body-output">P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000010000000000000004, lsn = 0/40000F8
       [filtered 5 lines of output]</pre></div></div><div class="section-body-text">Cette fois, il n'y a pas eu d'avertissement car une sauvegarde complète existait déjà. Alors que les sauvegardes incrémentielles peuvent être basées sur une sauvegarde complète <i> ou</i> différentielle, les sauvegardes différentielles doivent être basées sur une sauvegarde complète. Une sauvegarde complète peut être effectuée en exécutant la commande <span class="cmd">backup</span> avec <span class="br-setting">--type=full</span>.</div><div class="section-body-text">Vous trouverez plus d'informations sur la commande <span class="cmd">backup</span> dans la section <a href="#backup">Sauvegarde</a>.</div></div></div><div class="section2"><a id="quickstart/schedule-backup"></a><div class="section2-header"><div class="section2-number">6.10</div><div class="section2-title">Planifier une sauvegarde</div></div><div class="section-body"><div class="section-body-text">Des sauvegardes peuvent être programmées avec des utilitaires tels que cron.</div><div class="section-body-text">Dans l'exemple suivant, deux tâches 'cron' sont configurés pour fonctionner; les sauvegardes complètes sont programmées à 6h30 tous les dimanches, les sauvegardes différentielles à 6h30 du lundi au samedi. Si cette crontab est installée pour la première fois en milieu de semaine, alors <span class="backrest">pgBackRest</span> exécutera une sauvegarde complète la première fois que le job différentiel est exécuté, suivi le lendemain par une sauvegarde différentielle.</div><pre class="code-block">#m h   dom mon dow   command
30 06  *   *   0     pgbackrest --type=full --stanza=demo backup
30 06  *   *   1-6   pgbackrest --type=diff --stanza=demo backup</pre><div class="section-body-text">Une fois que les sauvegardes sont programmées, il est important de configurer la conservation de manière à ce que les sauvegardes expirent selon un calendrier définit, voir la section <a href="#retention">Retention</a>.</div></div></div><div class="section2"><a id="quickstart/backup-info"></a><div class="section2-header"><div class="section2-number">6.11</div><div class="section2-title">Informations sur les sauvegardes</div></div><div class="section-body"><div class="section-body-text">Utilisez la commande <span class="cmd">info</span> pour obtenir des informations sur les sauvegardes.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Obtenir des informations pour l'instance demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest info</pre><pre class="execute-body-output">stanza: demo
    status: ok
    cipher: aes-256-cbc

    db (current)
        wal archive min/max (9.6-1): 000000010000000000000002/000000010000000000000004
</pre><pre class="execute-body-output-highlight">        full backup: 20200408-110626F</pre><pre class="execute-body-output">            timestamp start/stop: 2020-04-08 11:06:26 / 2020-04-08 11:06:47
            wal start/stop: 000000010000000000000002 / 000000010000000000000002
            database size: 21MB, backup size: 21MB
            repository size: 2.5MB, repository backup size: 2.5MB
</pre><pre class="execute-body-output-highlight">        diff backup: 20200408-110626F_20200408-110649D</pre><pre class="execute-body-output">            timestamp start/stop: 2020-04-08 11:06:49 / 2020-04-08 11:06:53
            wal start/stop: 000000010000000000000004 / 000000010000000000000004
            database size: 21MB, backup size: 9.2KB
            repository size: 2.5MB, repository backup size: 768B
            backup reference list: 20200408-110626F</pre></div></div><div class="section-body-text">Chaque dépôts de sauvegarde a une section séparée et il est possible de limiter la sortie à un seul dépôt avec l'option <span class="br-option">--stanza</span>. L'indicateur <span class="id">status</span> donne une brève information sur l'état de santé du dépôt. S'il est à <span class="id">ok</span>, alors le <span class="backrest">pgBackRest</span> fonctionne normalement. La ligne <span class="id">wal min/max</span> indique les valeurs minimales et maximales des journaux de transaction (WAL) actuellement stockées dans le dépôt de sauvegarde. Notez qu'il peut y avoir des trous en raison des politiques de conservation des archives ou pour d'autres raisons.</div><div class="section-body-text">Les sauvegardes sont affichées du plus ancien au plus récent. La sauvegarde la plus ancienne sera <i>toujours</i> une sauvegarde complète (indiquée par un <span class="id">F</span> à la fin de l'étiquette) mais la sauvegarde la plus récente peut être complète, différentielle (se termine par <span class="id">D</span>), ou incrémentale (se termine par <span class="id">I</span>).</div><div class="section-body-text">La ligne '<span class="id">timestamp start/stop</span>' (horodatage de début/arrêt) définit la période pendant laquelle la sauvegarde s'est déroulée. Le paramètre <span class="id">timestamp stop</span> peut être utilisé pour déterminer quelle sauvegarde serait à utiliser lors d'une restauration PITR. Vous trouverez plus d'informations sur la restauration PITR dans la section <a href="#pitr">Récupération au point d'origine (PITR)</a>.</div><div class="section-body-text">La ligne <span class="id">wal start/stop</span> définit la plage de WAL qui est nécessaire pour rendre la base de données cohérente lors de la restauration. La commande <span class="cmd">backup</span> s'assure que cette plage de WAL se trouve bien dans le dépôt de sauvegarde avant de se terminer.</div><div class="section-body-text">L'information '<span class="id">database size</span>' (taille de la base de données) correspond à la taille totale non compressée de la base de données, tandis que l'information '<span class="id">backup size</span>' (taille de la sauvegarde) correspond à la quantité de données effectivement sauvegardées (ces informations seront les mêmes pour les sauvegardes complètes). L'information <span class="id">repository size</span> inclut tous les fichiers de cette sauvegarde et toutes les sauvegardes référencées qui sont nécessaires pour restaurer la base de données, tandis que l'information <span class="id">repository backup size</span> (taille du dépôt de sauvegarde) n'inclut que les fichiers de cette sauvegarde (ces informations seront également les mêmes pour les sauvegardes complètes). La taille des dépôts reflète la taille des fichiers compressés si la compression est activée dans <span class="backrest">pgBackRest</span> ou dans le système de fichiers.</div><div class="section-body-text">La ligne <span class="id">backup reference list</span> (liste de référence des sauvegardes) contient les sauvegardes supplémentaires qui sont nécessaires pour restaurer cette sauvegarde.</div></div></div><div class="section2"><a id="quickstart/perform-restore"></a><div class="section2-header"><div class="section2-number">6.12</div><div class="section2-title">Restauration d'une sauvegarde</div></div><div class="section-body"><div class="section-body-text">Les sauvegardes peuvent vous protéger contre de nombre de scénarios catastrophe, dont les plus courants sont une pannes matérielles et une corruption des données. La façon la plus simple de simuler une corruption de données est de supprimer un fichier important de l'instance <span class="postgres">PostgreSQL</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêt de l'instance demo et suppression du fichier <span class="file">pg_control</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres rm /var/lib/pgsql/9.6/data/global/pg_control</pre></div></div><div class="section-body-text">Le démarrage de l'instance <span class="postgres">PostgreSQL</span> sans ce fichier entraînera une erreur.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Tentative de démarrage de l'instance demo corrompue</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo systemctl status postgresql-9.6.service</pre><pre class="execute-body-output">       [filtered 8 lines of output]
Apr 08 11:06:55 pg-primary systemd[1]: Starting PostgreSQL 9.6 database server...
Apr 08 11:06:55 pg-primary systemd[1]: postgresql-9.6.service: main process exited, code=exited, status=2/INVALIDARGUMENT</pre><pre class="execute-body-output-highlight-error">Apr 08 11:06:55 pg-primary systemd[1]: Failed to start PostgreSQL 9.6 database server.</pre><pre class="execute-body-output">Apr 08 11:06:55 pg-primary systemd[1]: Unit postgresql-9.6.service entered failed state.
Apr 08 11:06:55 pg-primary systemd[1]: postgresql-9.6.service failed.</pre></div></div><div class="section-body-text">Pour restaurer une sauvegarde de l'instance <span class="postgres">PostgreSQL</span>, lancez <span class="backrest">pgBackRest</span> avec la commande <span class="cmd">restore</span>. L'instance doit être arrêté (dans ce cas, elle l'est déjà ) et tous les fichiers doivent être supprimés du répertoire de données <span class="postgres">PostgreSQL</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Suppression des anciens fichier de l'instance demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres find /var/lib/pgsql/9.6/data -mindepth 1 -delete</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Restauration et démarrage de l'instance <span class="postgres">PostgreSQL</span> demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo restore</pre><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre></div></div><div class="section-body-text">Cette fois, le cluster a démarré avec succès puisque la restauration a remplacé le fichier <span class="file">pg_control</span>.</div><div class="section-body-text">Vous trouverez plus d'informations sur la commande <span class="cmd">restore</span> dans la section <a href="#restore">Restauration</a>..</div></div></div></div></div><div class="section1"><a id="backup"></a><div class="section1-header"><div class="section1-number">7</div><div class="section1-title">Sauvegarde</div></div><div class="section-body"><div class="section-body-text">La section Sauvegarde introduit des fonctionnalités supplémentaires de la commande <span class="cmd">backup</span>.</div><div class="section2"><a id="backup/option-start-fast"></a><div class="section2-header"><div class="section2-number">7.1</div><div class="section2-title">Option de démarrage rapide</div></div><div class="section-body"><div class="section-body-text">Par défaut, <span class="backrest">pgBackRest</span> attendra le prochain point de contrôle régulier (Checkpoint) avant de commencer une sauvegarde. En fonction des paramètres <span class="pg-option">checkpoint_timeout</span> et <span class="pg-option">checkpoint_segments</span> de <span class="postgres">PostgreSQL</span>, il peut s'écouler un certain temps avant qu'un point de contrôle soit terminé et que la sauvegarde puisse commencer.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Sauvegarde incrémentale de l'instance demo avec le point de contrôle régulièrement programmé</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">P00   INFO: backup command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=demo --type=incr
P00   INFO: last backup label = 20200408-110626F_20200408-110649D, version = 2.25</pre><pre class="execute-body-output-highlight">P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the next regular checkpoint completes</pre><pre class="execute-body-output">P00   INFO: backup start archive = 000000020000000000000006, lsn = 0/6000028
P00   WARN: a timeline switch has occurred since the 20200408-110626F_20200408-110649D backup, enabling delta checksum
       [filtered 10 lines of output]</pre></div></div><div class="section-body-text">Lorsque <span class="br-setting">--start-fast</span> est transmis sur la ligne de commande ou que <span class="br-setting">start-fast=y</span> est défini dans le fichier de configuration <span class="file">/etc/pgbackrest/pgbackrest.conf</span>, un point de contrôle (checkpoint) immédiat est demandé sur l'instance <span class="postgres">PostgreSQL</span> et la sauvegarde démarre plus rapidement. C'est utile pour les tests et les sauvegardes exceptionnelles. Par exemple, si une sauvegarde est effectuée avant une plage de mainteance pour mise à jours, il est inutile d'attendre le prochain point de contrôle et donc il est utile de le forcer. Comme les sauvegardes planifiées ne se font généralement qu'une fois par jour, il est improbable que l'activation de <span class="br-option">start-fast</span> (démarrage rapide) dans <span class="file">/etc/pgbackrest/pgbackrest.conf</span> affecte négativement les performances. Cependant pour les systèmes à grand volume transctionnels, vous pouvez vouloir passer <span class="br-setting">--start-fast</span> sur la ligne de commande à la place. Il est également possible d'ignorer le paramètre du fichier de configuration en utilisant le paramètre <span class="br-setting">--no-start-fast</span> de la ligne de commande.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Activation du paramètre <span class="br-option">start-fast</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-cipher-pass=zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO<br/>
repo1-cipher-type=aes-256-cbc<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Sauvegarde incrémentale de l'instance demo avec un point de contrôle immédiat (immediat checkpoint)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr \
       --log-level-console=info backup</pre><pre class="execute-body-output">P00   INFO: backup command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=demo --start-fast --type=incr
P00   INFO: last backup label = 20200408-110626F_20200408-110710I, version = 2.25</pre><pre class="execute-body-output-highlight">P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes</pre><pre class="execute-body-output">P00   INFO: backup start archive = 000000020000000000000007, lsn = 0/7000028
P01   INFO: backup file /var/lib/pgsql/9.6/data/global/pg_control (8KB, 81%) checksum ab1fa2da5caf572b3392978fcc76efb276d833bd
       [filtered 9 lines of output]</pre></div></div></div></div><div class="section2"><a id="backup/option-archive-timeout"></a><div class="section2-header"><div class="section2-number">7.2</div><div class="section2-title">Timeout des archives</div></div><div class="section-body"><div class="section-body-text">Lors d'une sauvegarde à chaud, <span class="backrest">pgBackRest</span> attend que les segments WAL qui sont nécessaires à la cohérence de la sauvegarde soient archivés. Ce temps d'attente est régi par l'option <span class="backrest">pgBackRest</span> <span class="br-option">archive-timeout</span> dont la valeur par défaut est de 60 secondes. Si l'on sait que l'archivage d'un segment individuel prend plus de temps, cette option doit être augmentée.</div></div></div></div></div><div class="section1"><a id="monitor"></a><div class="section1-header"><div class="section1-number">8</div><div class="section1-title">Supervision</div></div><div class="section-body"><div class="section-body-text">La supervision est un élément important de tout système de production. De nombreux outils sont disponibles et il est possible de contrôler n'importe lequel d'entre eux avec un peu de travail.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> peut produire des informations sur le dépôt au format JSON qui comprend une liste de toutes les sauvegardes pour chaque dépots de sauvegardes et des informations sur les archives WAL.</div><div class="section2"><a id="monitor/postgresql"></a><div class="section2-header"><div class="section2-number">8.1</div><div class="section2-title">Dans <span class="postgres">PostgreSQL</span></div></div><div class="section-body"><div class="section-body-text">La commande <span class="postgres">PostgreSQL</span> <span class="id">COPY</span> permet de charger les informations <span class="backrest">pgBackRest</span> dans un tableau. L'exemple suivant résume cette logique dans une fonction qui peut être utilisée pour effectuer des requêtes en temps réel.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Charger la fonction d'information de <span class="backrest">pgBackRest</span> dans <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat \
       /var/lib/pgsql/pgbackrest/doc/example/pgsql-pgbackrest-info.sql</pre><pre class="execute-body-output">-- An example of monitoring pgBackRest from within PostgreSQL
--
-- Use copy to export data from the pgBackRest info command into the jsonb
-- type so it can be queried directly by PostgreSQL.

-- Create monitor schema
create schema monitor;

-- Get pgBackRest info in JSON format
create function monitor.pgbackrest_info()
    returns jsonb AS $$
declare
    data jsonb;
begin
    -- Create a temp table to hold the JSON data
    create temp table temp_pgbackrest_data (data jsonb);

    -- Copy data into the table directly from the pgBackRest info command
    copy temp_pgbackrest_data (data)
        from program
            'pgbackrest --output=json info' (format text);

    select temp_pgbackrest_data.data
      into data
      from temp_pgbackrest_data;

    drop table temp_pgbackrest_data;

    return data;
end $$ language plpgsql;</pre><pre class="execute-body-cmd">sudo -u postgres psql -f \
       /var/lib/pgsql/pgbackrest/doc/example/pgsql-pgbackrest-info.sql</pre></div></div><div class="section-body-text">Vous pouvez à présent utiliser la fonction <span class="id">monitor.pgbackrest_info()</span> pour déterminer la dernière sauvegarde réussie et les WAL archivés pour un dépots de sauvegarde.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Interroger la dernière sauvegarde réussie et les WAL archivés</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat \
       /var/lib/pgsql/pgbackrest/doc/example/pgsql-pgbackrest-query.sql</pre><pre class="execute-body-output">-- Get last successful backup for each stanza
--
-- Requires the monitor.pgbackrest_info function.
with stanza as
(
    select data->'name' as name,
           data->'backup'->(
               jsonb_array_length(data->'backup') - 1) as last_backup,
           data->'archive'->(
               jsonb_array_length(data->'archive') - 1) as current_archive
      from jsonb_array_elements(monitor.pgbackrest_info()) as data
)
select name,
       to_timestamp(
           (last_backup->'timestamp'->>'stop')::numeric) as last_successful_backup,
       current_archive->>'max' as last_archived_wal
  from stanza;</pre><pre class="execute-body-cmd">sudo -u postgres psql -f \
       /var/lib/pgsql/pgbackrest/doc/example/pgsql-pgbackrest-query.sql</pre><pre class="execute-body-output">  name  | last_successful_backup |    last_archived_wal     
--------+------------------------+--------------------------
 "demo" | 2020-04-08 11:07:21+00 | 000000020000000000000007
(1 row)</pre></div></div></div></div></div></div><div class="section1"><a id="retention"></a><div class="section1-header"><div class="section1-number">9</div><div class="section1-title">Rétention</div></div><div class="section-body"><div class="section-body-text">En général, il est préférable de conserver autant de sauvegardes que possible afin d'offrir une plus grande fenêtre de <a href="#pitr">récupération par PITR</a>, mais il faut également tenir compte de préoccupations pratiques telles que l'espace disque. Les options de conservation permettent de supprimer les anciennes sauvegardes lorsqu'elles ne sont plus nécessaires.</div><div class="section2"><a id="retention/full"></a><div class="section2-header"><div class="section2-number">9.1</div><div class="section2-title">Conservation de la sauvegarde complète</div></div><div class="section-body"><div class="section-body-text">Modifiez <span class="br-option">repo1-retention-full</span> sur le nombre de sauvegardes complètes souhaitées. Les nouvelles sauvegardes doivent être effectuées avant l'expiration &mdash ; cela signifie que si <span class="br-setting">repo1-retention-full=2</span> alors il y aura trois sauvegardes complètes stockées avant l'expiration de la plus ancienne.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de l'option <span class="br-option">repo1-retention-full</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-cipher-pass=zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO<br/>
repo1-cipher-type=aes-256-cbc<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="section-body-text">Le paramètre est fixé à <span class="br-setting">repo1-retention-full=2</span> mais actuellement il n'y a qu'une seule sauvegarde complète de sorte que la prochaine sauvegarde complète qui sera exécutée ne fera expirer aucune autre sauvegarde complète.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Effectuer une sauvegarde complète</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=full \
       --log-level-console=detail backup</pre><pre class="execute-body-output">       [filtered 875 lines of output]
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.25: --log-level-console=detail --log-level-stderr=off --no-log-timestamp --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00 DETAIL: archive retention on backup 20200408-110626F, archiveId = 9.6-1, start = 000000010000000000000002</pre><pre class="execute-body-output">P00 DETAIL: no archive to remove, archiveId = 9.6-1
P00   INFO: expire command end: completed successfully</pre></div></div><div class="section-body-text">Des archives <i>ont</i> expiré puisque des segments WAL ont été générés avant la plus ancienne sauvegarde. Ils ne sont pas utiles pour la restauration &mdash ; seuls les segments WAL générés après une sauvegarde peuvent être utilisés lors de la restauration de cette sauvegarde.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Effectuer une sauvegarde complète</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=full \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 874 lines of output]
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: expire full backup set: 20200408-110626F, 20200408-110626F_20200408-110649D, 20200408-110626F_20200408-110710I, 20200408-110626F_20200408-110717I</pre><pre class="execute-body-output">P00   INFO: remove expired backup 20200408-110626F_20200408-110717I
P00   INFO: remove expired backup 20200408-110626F_20200408-110710I
       [filtered 2 lines of output]</pre></div></div><div class="section-body-text">La sauvegarde complète <span class="id">20200408-110626F</span> a expiré et la conservation des archives est basée sur la sauvegarde <span class="id">20200408-110726F</span> qui est désormais la plus ancienne sauvegarde complète.</div></div></div><div class="section2"><a id="retention/diff"></a><div class="section2-header"><div class="section2-number">9.2</div><div class="section2-title">Rétention de la sauvegarde différentielle</div></div><div class="section-body"><div class="section-body-text">Modifiez <span class="br-option">repo1-retention-diff</span> sur le nombre de sauvegardes différentielles souhaitées. Les sauvegardes différentiels ne reposent que sur la sauvegarde complète antérieure, de sorte qu'il est possible de créer un ensemble de sauvegardes différentielles pour le dernier jour ou plus. Cela permet de restaurer rapidement vers un point de sauvegarde dans le temps (points-in-time) mais diminue la quantité globale d'espace disponible.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="br-option">repo1-retention-diff</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-cipher-pass=zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO<br/>
repo1-cipher-type=aes-256-cbc<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-diff=1<br/>
repo1-retention-full=2<br/>
start-fast=y<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="section-body-text">La sauvegarde effectuera <span class="br-setting">repo1-retention-diff=1</span> donc deux différentiels devront être réalisés avant que l'un d'entre eux ne soit expiré. Une sauvegarde incrémentale est ajoutée pour illustrer l'expiration incrémentale. Les sauvegardes incrémentales ne peuvent pas expirer de façon individuelle &mdash ; elles expirent toujours avec leur sauvegarde complète ou différentielle correspondante.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Effectuer des sauvegardes différentielles et incrémentales</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff backup</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr backup</pre></div></div><div class="section-body-text">Le fait de procéder maintenant à une sauvegarde différentielle fera expirer les sauvegardes différentielles et incrémentales précédentes, ne laissant qu'une seule sauvegarde différentielle.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Effectuer une sauvegarde différentielle</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 12 lines of output]
P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-diff=1 --repo1-retention-full=2 --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: expire diff backup set: 20200408-110748F_20200408-110810D, 20200408-110748F_20200408-110816I</pre><pre class="execute-body-output">P00   INFO: remove expired backup 20200408-110748F_20200408-110816I
P00   INFO: remove expired backup 20200408-110748F_20200408-110810D</pre></div></div></div></div><div class="section2"><a id="retention/archive"></a><div class="section2-header"><div class="section2-number">9.3</div><div class="section2-title">Rétention des archives</div></div><div class="section-body"><div class="section-body-text">Bien que <span class="backrest">pgBackRest</span> supprime automatiquement les segments WAL archivés lors de l'expiration des sauvegardes (la valeur par défaut d'expiration des WAL pour les sauvegardes complètes se base sur l'option <span class="br-option">repo1-retention-full</span>), il peut être utile de faire expirer les archives de manière plus agressive pour économiser de l'espace disque. Notez que les sauvegardes complètes sont considérées comme des sauvegardes différentielles dans le but d'une conservation différentielle des archives.</div><div class="section-body-text">Les archives qui expirent ne supprimeront jamais les segments de WAL qui sont nécessaires pour rendre une sauvegarde cohérente. Toutefois, étant donné que la récupération ponctuelle (PITR) ne fonctionne que sur un flux WAL continu, il convient d'être prudent en cas d'expiration agressive des archives en dehors du processus normal d'expiration des sauvegardes.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="br-option">repo1-retention-diff</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-cipher-pass=zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO<br/>
repo1-cipher-type=aes-256-cbc<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-diff=2<br/>
repo1-retention-full=2<br/>
start-fast=y<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Effectuer une sauvegarde différentielle</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff \
       --log-level-console=info backup</pre><pre class="execute-body-output">       [filtered 9 lines of output]
P00   INFO: backup stop archive = 000000020000000000000011, lsn = 0/110000F8
P00   INFO: check archive for segment(s) 000000020000000000000011:000000020000000000000011</pre><pre class="execute-body-output-highlight">P00   INFO: new backup label = 20200408-110748F_20200408-110828D</pre><pre class="execute-body-output">P00   INFO: backup command end: completed successfully
P00   INFO: expire command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-diff=2 --repo1-retention-full=2 --stanza=demo</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Expire archive</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=detail \
       --repo1-retention-archive-type=diff --repo1-retention-archive=1 expire</pre><pre class="execute-body-output">P00   INFO: expire command begin 2.25: --log-level-console=detail --log-level-stderr=off --no-log-timestamp --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/var/lib/pgbackrest --repo1-retention-archive=1 --repo1-retention-archive-type=diff --repo1-retention-diff=2 --repo1-retention-full=2 --stanza=demo
P00 DETAIL: archive retention on backup 20200408-110726F, archiveId = 9.6-1, start = 000000020000000000000009, stop = 000000020000000000000009
P00 DETAIL: archive retention on backup 20200408-110748F, archiveId = 9.6-1, start = 00000002000000000000000A, stop = 00000002000000000000000A</pre><pre class="execute-body-output-highlight">P00 DETAIL: archive retention on backup 20200408-110748F_20200408-110820D, archiveId = 9.6-1, start = 00000002000000000000000E, stop = 00000002000000000000000E</pre><pre class="execute-body-output">P00 DETAIL: archive retention on backup 20200408-110748F_20200408-110828D, archiveId = 9.6-1, start = 000000020000000000000011</pre><pre class="execute-body-output-highlight">P00 DETAIL: remove archive: archiveId = 9.6-1, start = 00000002000000000000000B, stop = 00000002000000000000000D
P00 DETAIL: remove archive: archiveId = 9.6-1, start = 00000002000000000000000F, stop = 000000020000000000000010</pre><pre class="execute-body-output">P00   INFO: expire command end: completed successfully</pre></div></div><div class="section-body-text">La sauvegarde différentielle <span class="id">20200408-110748F_20200408-110820D</span> a archivé des segments WAL qui doivent être conservés pour rendre les anciennes sauvegardes cohérentes même si elles ne peuvent pas être jouées ultérieurement avec PITR. Les segments WAL générés après la sauvegarde <span class="id">20200408-110748F_20200408-110820D</span> mais avant <span class="id">20200408-110748F_20200408-110828D</span> sont supprimés. Les segments WAL générés après la nouvelle sauvegarde <span class="id">20200408-110748F_20200408-110828D</span> sont conservés et peuvent être utilisés pour le PITR.</div><div class="section-body-text">Étant donné que les sauvegardes complètes sont considérées comme des sauvegardes différentielles pour la conservation différentielle des archives, si une sauvegarde complète est maintenant effectuée avec les mêmes paramètres, seule l'archive de cette sauvegarde complète est conservée pour PITR.</div></div></div></div></div><div class="section1"><a id="restore"></a><div class="section1-header"><div class="section1-number">10</div><div class="section1-title">Restauration</div></div><div class="section-body"><div class="section-body-text">La section Restauration introduit des fonctionnalités supplémentaires de la commande <span class="cmd">restore</span>.</div><div class="section2"><a id="restore/ownership"></a><div class="section2-header"><div class="section2-number">10.1</div><div class="section2-title">Propriétaire du fichier</div></div><div class="section-body"><div class="section-body-text">Lorsqu'un <span class="cmd">restore</span> est exécuté en tant qu'utilisateur non root (scénario typique), tous les fichiers restaurés appartiendront à l'utilisateur/groupe qui exécute le <span class="backrest">pgBackRest</span>. Si les fichiers existants ne sont pas la propriété de l'utilisateur/groupe en cours d'exécution, une erreur se produira si le propriétaire ne peut pas être mise à jour pour l'utilisateur/groupe en cours d'exécution. Dans ce cas, la propriété du fichier devra être mise à jour par un utilisateur privilégié avant que la restauration ne puisse être réexécutée.</div><div class="section-body-text">Lorsqu'un <span class="cmd">restore</span> est exécuté en tant qu'utilisateur <span class="id">root</span>, le <span class="backrest">pgBackRest</span> tentera de recréer la propriété enregistrée dans le manifeste de la sauvegarde. Seuls les <b>noms</b> des utilisateurs/groupes sont stockés dans le manifeste, de sorte que les mêmes noms doivent exister sur l'hôte de restauration pour que cela fonctionne. Si le nom de l'utilisateur/groupe ne peut être trouvé localement, l'utilisateur/groupe du répertoire de données <span class="postgres">PostgreSQL</span> sera utilisé et enfin si l'utilisateur/groupe du répertoire de données ne peut être associé à un nom, <span class="id">root</span> sera utilisé.</div></div></div><div class="section2"><a id="restore/option-delta"></a><div class="section2-header"><div class="section2-number">10.2</div><div class="section2-title">Option de Delta</div></div><div class="section-body"><div class="section-body-text">Dans la section <a href="#quickstart/perform-restore">Restauration d'une sauvegarde</a> du <a href="#quickstart">Guide de démarrage rapide</a> a exigé que le répertoire de l'instance soit vidé avant d'effectuer le <span class="cmd">restore</span>. L'option <span class="br-option">delta</span> permet à <span class="backrest">pgBackRest</span> de déterminer automatiquement quels fichiers du répertoire de l'instance de base de données peuvent être préservés et lesquels doivent être restaurés à partir de la sauvegarde &mdash ; elle permet également de <i>supprimer</i> les fichiers non présents dans le manifeste de sauvegarde afin de se débarrasser des modifications divergeantes. Cette opération est réalisée en calculant un hachage cryptographique <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> sur chacun des fichiers présents dans le répertoire de données de l'instance. Si le hachage <span class="id">SHA-1</span> ne correspond pas au hachage stocké dans la sauvegarde, le fichier sera restauré. Cette opération est très efficace lorsqu'elle est combinée avec l'option <span class="br-option">process-max</span>. Étant donné que le serveur <span class="postgres">PostgreSQL</span> est arrêté pendant la restauration, il est possible d'utiliser un plus grand nombre de processus que ce qui pourrait être envisagé durant une sauvegarde (lorsque l'instance <span class="postgres">PostgreSQL</span> est en cours d'exécution).</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêt de l'instance demo, effectuer une restauration delta</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --log-level-console=detail restore</pre><pre class="execute-body-output">       [filtered 2 lines of output]
P00 DETAIL: check '/var/lib/pgsql/9.6/data' exists
P00 DETAIL: remove 'global/pg_control' so cluster will not start if restore does not complete</pre><pre class="execute-body-output-highlight">P00   INFO: remove invalid files/links/paths from '/var/lib/pgsql/9.6/data'</pre><pre class="execute-body-output">P00 DETAIL: remove invalid file '/var/lib/pgsql/9.6/data/backup_label.old'
P00 DETAIL: remove invalid file '/var/lib/pgsql/9.6/data/base/12470/pg_internal.init'
       [filtered 914 lines of output]</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Redémarrage de <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre></div></div></div></div><div class="section2"><a id="restore/option-db-include"></a><div class="section2-header"><div class="section2-number">10.3</div><div class="section2-title">Restaurer des bases de données sélectionnées</div></div><div class="section-body"><div class="section-body-text">Dans certains cas, il peut être intéressant de restaurer de façon sélective des bases de données spécifiques à partir d'une sauvegarde d'instance. Cela peut être fait pour des raisons de performance ou pour déplacer les bases de données sélectionnées vers une machine qui n'a pas assez d'espace pour restaurer l'ensemble de la sauvegarde de l'instance</div><div class="section-body-text">Pour illustrer cette fonctionnalité, deux bases de données sont créées : test1 et test2. Une nouvelle sauvegarde est effectuée afin que <span class="backrest">pgBackRest</span> soit informé des nouvelles bases de données.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Créer deux bases de données de test et effectuer une sauvegarde</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "create database test1;"</pre><pre class="execute-body-output">CREATE DATABASE</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "create database test2;"</pre><pre class="execute-body-output">CREATE DATABASE</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr backup</pre></div></div><div class="section-body-text">Chaque base de données de test sera alimentée par des tables et des données pour illustrer que la restauration fonctionne avec une restauration sélective.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Créer une table de test dans chaque base de données</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "create table test1_table (id int); \
       insert into test1_table (id) values (1);" test1</pre><pre class="execute-body-output">INSERT 0 1</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "create table test2_table (id int); \
       insert into test2_table (id) values (2);" test2</pre><pre class="execute-body-output">INSERT 0 1</pre></div></div><div class="section-body-text">L'une des principales raisons de recourir à la restauration sélective est le gain d'espace. La taille de la base de données test1 est indiquée ici afin de pouvoir la comparer avec l'utilisation du disque après une restauration sélective.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Afficher l'espace utilisé par la base de données test1</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres du -sh /var/lib/pgsql/9.6/data/base/24576</pre><pre class="execute-body-output">7.0M	/var/lib/pgsql/9.6/data/base/24576</pre></div></div><div class="section-body-text">Si la base de données à restaurer n'est pas connue, utilisez l'option de commande <span class="cmd">info</span> command <span class="br-option">set</span> pour découvrir les bases de données qui font partie du jeu de sauvegarde.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Afficher la liste des bases de données de la sauvegarde</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo \
       --set=20200408-110748F_20200408-110844I info</pre><pre class="execute-body-output">       [filtered 11 lines of output]
            repository size: 4MB, repository backup size: 1.6MB
            backup reference list: 20200408-110748F, 20200408-110748F_20200408-110828D</pre><pre class="execute-body-output-highlight">            database list: postgres (12470), test1 (24576), test2 (24577)</pre></div></div><div class="section-body-text">Arrêtez l'instance et ne restaurez que la base de données test2. Les bases de données intégrées (<span class="id">template0</span>, <span class="id">template1</span>, et <span class="id">postgres</span>) sont toujours restaurées.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Restauration de la dernière sauvegarde incluant uniquement la base de données test2</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --db-include=test2 restore</pre><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre></div></div><div class="section-body-text">Une fois la récupération terminée, la base de données test2 contiendra toutes les tables et données créées précédemment.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Démontration que la base de données test2 a été récupérée</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from test2_table;" test2</pre><pre class="execute-body-output"> id 
----
  2
(1 row)</pre></div></div><div class="section-body-text">La base de données <q>test1</q>, malgré une récupération réussie, n'est pas accessible. Cela est dû au fait que la base de données entière a été restaurée sous forme de fichiers épars et mis à zéro. <span class="postgres">PostgreSQL</span> peut appliquer des WALs avec succès sur les fichiers mis à zéro mais la base de données dans son ensemble ne sera pas valide car les fichiers clés ne contiennent pas de données. Ceci est destiné à éviter que la base de données soit accidentellement utilisée alors qu'elle pourrait contenir des données partielles qui ont été appliquées lors de la relecture de WAL.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Tenter de se connecter à la base de données test1 produira une erreur</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from test1_table;" test1</pre><pre class="execute-body-output-highlight-error">psql: FATAL:  relation mapping file "base/24576/pg_filenode.map" contains invalid data</pre></div></div><div class="section-body-text">Comme la base de données test1 est restaurée avec des fichiers épars et mis à zéro, elle ne nécessitera qu'autant d'espace que la quantité de WAL qui est écrite pendant la récupération. Bien que la quantité de WAL générée lors d'une sauvegarde et appliquée lors de la récupération puisse être importante, elle ne représentera généralement qu'une petite fraction de la taille totale de la base de données, en particulier pour les grandes bases de données où cette fonctionnalité est la plus susceptible d'être utile.</div><div class="section-body-text">Il est clair que la base de données test1 utilise beaucoup moins d'espace disque pendant la restauration sélective qu'elle ne l'aurait fait si toute la base de données avait été restaurée.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Afficher l'espace utilisé par la base de données test1 après la récupération</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres du -sh /var/lib/pgsql/9.6/data/base/24576</pre><pre class="execute-body-output">152K	/var/lib/pgsql/9.6/data/base/24576</pre></div></div><div class="section-body-text">À ce stade, la seule action qui peut être entreprise sur la base de données de test1 invalide est <span class="id">drop database</span>. <span class="backrest">pgBackRest</span> ne supprime pas automatiquement la base de données puisque cela ne peut pas être fait tant que la récupération n'est pas terminée et que l'instance n'est pas accessible.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Supprimer la base de données du test1</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "drop database test1;"</pre><pre class="execute-body-output">DROP DATABASE</pre></div></div><div class="section-body-text">Maintenant que la base de données invalide du test1 a été supprimée, il ne reste plus que le test2 et les bases de données internes.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Liste des bases de données restantes</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select oid, datname from pg_database order by oid;"</pre><pre class="execute-body-output">  oid  |  datname  
-------+-----------
     1 | template1
 12469 | template0
 12470 | postgres</pre><pre class="execute-body-output-highlight"> 24577 | test2</pre><pre class="execute-body-output">(4 rows)</pre></div></div></div></div></div></div><div class="section1"><a id="pitr"></a><div class="section1-header"><div class="section1-number">11</div><div class="section1-title">Point-in-Time Recovery</div></div><div class="section-body"><div class="section-body-text"><a href="#quickstart/perform-restore">Restaurer une sauvegarde</a> de la section <a href="#quickstart">Démarrage Rapide</a> effectue une récupération par défaut, qui doit se poursuivre jusqu'à la fin du flux de WAL. En cas de défaillance matérielle, c'est généralement le meilleur choix, mais pour les scénarios de corruption de données (qu'elles soient d'origine machine ou humaine), la récupération ponctuelle (PITR) est souvent plus appropriée</div><div class="section-body-text">La récupération ponctuelle (PITR) permet de lire les WAL depuis la dernière sauvegarde jusqu'à une heure, un identifiant de transaction ou un point de récupération spécifié. Pour les scénarios de récupération courants, la récupération basée sur le temps est sans doute la plus utile. Un scénario de récupération typique consiste à restaurer une table qui a été accidentellement supprimée ou des données qui ont été accidentellement effacées. La récupération d'une table supprimée est plus spectaculaire, c'est donc l'exemple donné ici, mais des données supprimées seraient récupérées exactement de la même manière.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Sauvegarder l'instance demo et créer une table avec des données très importantes</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=diff backup</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "begin; \
       create table important_table (message text); \
       insert into important_table values ('Important Data'); \
       commit; \
       select * from important_table;"</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">Il est important de faire correspondre l'heure à celle calculée par <span class="postgres">PostgreSQL</span> et d'inclure les décalages de fuseau horaire. Cela réduit la possibilité de conversions involontaires de fuseau horaire et d'un résultat de récupération inattendu.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Obtenez l'heure à partir de <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -Atc "select current_timestamp"</pre><pre class="execute-body-output">2020-04-08 11:09:27.677835+00</pre></div></div><div class="section-body-text">Maintenant que l'heure a été enregistrée, le tableau est supprimé. En pratique, il est beaucoup plus difficile de trouver l'heure exacte à laquelle la table a été supprimée que dans cet exemple. Il n'est peut-être pas possible de trouver l'heure exacte, mais un travail de recherche devrait vous permettre de vous en rapprocher.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Supprimer la table importante</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "begin; \
       drop table important_table; \
       commit; \
       select * from important_table;"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "important_table" does not exist</pre><pre class="execute-body-output">LINE 1: ...le important_table;     commit;     select * from important_...
                                                             ^</pre></div></div><div class="section-body-text">Maintenant, la restauration peut être effectuée avec une récupération basée sur le temps pour récupérer la table perdue.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêtez <span class="postgres">PostgreSQL</span>, restaurez l'instance demo à <span class="id">2020-04-08 11:09:27.677835+00</span>, et affichez le fichier <span class="file">recovery.conf</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --type=time "--target=2020-04-08 11:09:27.677835+00" \
       --target-action=promote restore</pre><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/recovery.conf</pre><pre class="execute-body-output"># Recovery settings generated by pgBackRest restore on 2020-04-08 11:09:31
restore_command = 'pgbackrest --stanza=demo archive-get %f "%p"'</pre><pre class="execute-body-output-highlight">recovery_target_time = '2020-04-08 11:09:27.677835+00'</pre><pre class="execute-body-output">recovery_target_action = 'promote'</pre></div></div><div class="section-body-text">Le fichier <span class="file">recovery.conf</span> a été généré automatiquement par <span class="backrest">pgBackRest</span>, de sorte que <span class="postgres">PostgreSQL</span> peut être lancé immédiatement. Une fois que <span class="postgres">PostgreSQL</span> a terminé la récupération, la table existera de nouveau et pourra être interrogée.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Démarrez <span class="postgres">PostgreSQL</span> et vérifiez que la table important existe</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from important_table"</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">Les traces de <span class="postgres">PostgreSQL</span> contiennent également des informations précieuses. Ils indiqueront l'heure et la transaction où la récupération s'est arrêtée et donnera également l'heure de la dernière transaction appliquée.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Examiner la sortie des traces <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/pg_log/postgresql.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2020-04-08 11:09:16 UTC</pre><pre class="execute-body-output-highlight">LOG:  starting point-in-time recovery to 2020-04-08 11:09:27.677835+00</pre><pre class="execute-body-output">LOG:  restored log file "00000004.history" from archive
LOG:  restored log file "000000040000000000000016" from archive
LOG:  redo starts at 0/16000028
LOG:  consistent recovery state reached at 0/160000F8
LOG:  restored log file "000000040000000000000017" from archive</pre><pre class="execute-body-output-highlight">LOG:  recovery stopping before commit of transaction 639, time 2020-04-08 11:09:29.512933+00</pre><pre class="execute-body-output">LOG:  redo done at 0/17020460</pre><pre class="execute-body-output-highlight">LOG:  last completed transaction was at log time 2020-04-08 11:09:25.848009+00</pre><pre class="execute-body-output">LOG:  selected new timeline ID: 5
LOG:  archive recovery complete
       [filtered 4 lines of output]</pre></div></div><div class="section-body-text">Cet exemple a été truqué pour donner le bon résultat. Si une sauvegarde après le temps requis est choisie, alors <span class="postgres">PostgreSQL</span> ne pourra pas récupérer la table perdue. <span class="postgres">PostgreSQL</span> ne peut jouer que vers l'avant, pas vers l'arrière. Pour le démontrer, la table importante doit être abandonnée (de nouveau).</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Supprimer la table importante (de nouveau)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "begin; \
       drop table important_table; \
       commit; \
       select * from important_table;"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "important_table" does not exist</pre><pre class="execute-body-output">LINE 1: ...le important_table;     commit;     select * from important_...
                                                             ^</pre></div></div><div class="section-body-text">Prenez maintenant une nouvelle sauvegarde et essayez de récupérer à partir de la nouvelle sauvegarde en spécifiant l'option <span class="br-option">{--set</span>. La commande <span class="cmd">info</span> peut être utilisée pour trouver le nouveau label de la sauvegarde.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Effectuer une sauvegarde et obtenir des informations sur la sauvegarde</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=incr backup</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest info</pre><pre class="execute-body-output">stanza: demo
    status: ok
    cipher: aes-256-cbc

    db (current)
        wal archive min/max (9.6-1): 000000020000000000000009/000000050000000000000018

        full backup: 20200408-110726F
            timestamp start/stop: 2020-04-08 11:07:26 / 2020-04-08 11:07:46
            wal start/stop: 000000020000000000000009 / 000000020000000000000009
            database size: 21MB, backup size: 21MB
            repository size: 2.5MB, repository backup size: 2.5MB

        full backup: 20200408-110748F
            timestamp start/stop: 2020-04-08 11:07:48 / 2020-04-08 11:08:08
            wal start/stop: 00000002000000000000000A / 00000002000000000000000A
            database size: 21MB, backup size: 21MB
            repository size: 2.5MB, repository backup size: 2.5MB

        diff backup: 20200408-110748F_20200408-110828D
            timestamp start/stop: 2020-04-08 11:08:28 / 2020-04-08 11:08:32
            wal start/stop: 000000020000000000000011 / 000000020000000000000011
            database size: 21MB, backup size: 99.9KB
            repository size: 2.5MB, repository backup size: 11.9KB
            backup reference list: 20200408-110748F

        incr backup: 20200408-110748F_20200408-110844I
            timestamp start/stop: 2020-04-08 11:08:44 / 2020-04-08 11:09:00
            wal start/stop: 000000030000000000000013 / 000000030000000000000013
            database size: 34.7MB, backup size: 13.7MB
            repository size: 4MB, repository backup size: 1.6MB
            backup reference list: 20200408-110748F, 20200408-110748F_20200408-110828D

        diff backup: 20200408-110748F_20200408-110915D
            timestamp start/stop: 2020-04-08 11:09:15 / 2020-04-08 11:09:24
            wal start/stop: 000000040000000000000016 / 000000040000000000000016
            database size: 27.9MB, backup size: 7.0MB
            repository size: 3.3MB, repository backup size: 847KB
            backup reference list: 20200408-110748F
</pre><pre class="execute-body-output-highlight">        incr backup: 20200408-110748F_20200408-110938I</pre><pre class="execute-body-output">            timestamp start/stop: 2020-04-08 11:09:38 / 2020-04-08 11:09:43
            wal start/stop: 000000050000000000000018 / 000000050000000000000018
            database size: 27.9MB, backup size: 2MB
            repository size: 3.3MB, repository backup size: 211.5KB
            backup reference list: 20200408-110748F, 20200408-110748F_20200408-110915D</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Tentative de récupération à partir de la sauvegarde spécifiée</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --set=20200408-110748F_20200408-110938I \
       --type=time "--target=2020-04-08 11:09:27.677835+00" --target-action=promote restore</pre><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from important_table"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "important_table" does not exist</pre><pre class="execute-body-output">LINE 1: select * from important_table
                      ^</pre></div></div><div class="section-body-text">En regardant le journal de sortie, il n'est pas évident que la récupération n'a pas réussi à restaurer la table. La solution consiste à rechercher la présence des messages de journal <q>recovery stopping before...</q> (arrêt de la récupération avant...) et <q>last completed transaction..</q> (dernière transaction effectuée...). S'ils ne sont pas présents, alors la récupération au point spécifié dans le temps n'a pas réussi.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Examiner la sortie du journal <span class="postgres">PostgreSQL</span> pour constater que la récupération n'a pas réussi</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/pg_log/postgresql.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2020-04-08 11:09:39 UTC</pre><pre class="execute-body-output-highlight">LOG:  starting point-in-time recovery to 2020-04-08 11:09:27.677835+00</pre><pre class="execute-body-output">LOG:  restored log file "00000005.history" from archive
LOG:  restored log file "000000050000000000000018" from archive
LOG:  redo starts at 0/18000028</pre><pre class="execute-body-output-highlight">LOG:  consistent recovery state reached at 0/180000F8</pre><pre class="execute-body-output">LOG:  redo done at 0/180000F8
LOG:  restored log file "000000050000000000000018" from archive
       [filtered 7 lines of output]</pre></div></div><div class="section-body-text">Le comportement par défaut pour la restauration basée sur le temps, si l'option <span class="br-option">--set</span> n'est pas spécifiée, est de tenter de découvrir une sauvegarde antérieure pour la rejouer. Si un jeu de sauvegarde ne peut pas être trouvé, alors la restauration se fera par défaut sur la dernière sauvegarde qui, comme indiqué précédemment, peut ne pas donner le résultat souhaité.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêter <span class="postgres">PostgreSQL</span>, restaurer à partir de la sauvegarde sélectionnée automatiquement, et démarrez <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta \
       --type=time "--target=2020-04-08 11:09:27.677835+00" \
       --target-action=promote restore</pre><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from important_table"</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">Maintenant, la sortie du journal (traces) contiendra les messages attendus <q>recovery stopping before...</q> (arrêt de la récupération avant...) et <q>last completed transaction...</q> (dernière transaction terminée...) indiquant que la récupération a réussi.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Examiner la sortie du journal (traces) de <span class="postgres">PostgreSQL</span> pour les messages indiquant le succès</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/pg_log/postgresql.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2020-04-08 11:09:16 UTC</pre><pre class="execute-body-output-highlight">LOG:  starting point-in-time recovery to 2020-04-08 11:09:27.677835+00</pre><pre class="execute-body-output">LOG:  restored log file "00000004.history" from archive
LOG:  restored log file "000000040000000000000016" from archive
LOG:  redo starts at 0/16000028
LOG:  consistent recovery state reached at 0/160000F8
LOG:  restored log file "000000040000000000000017" from archive</pre><pre class="execute-body-output-highlight">LOG:  recovery stopping before commit of transaction 639, time 2020-04-08 11:09:29.512933+00</pre><pre class="execute-body-output">LOG:  redo done at 0/17020460</pre><pre class="execute-body-output-highlight">LOG:  last completed transaction was at log time 2020-04-08 11:09:25.848009+00</pre><pre class="execute-body-output">LOG:  restored log file "00000005.history" from archive
LOG:  restored log file "00000006.history" from archive
       [filtered 6 lines of output]</pre></div></div></div></div><div class="section1"><a id="s3-support"></a><div class="section1-header"><div class="section1-number">12</div><div class="section1-title">Support de S3-Compatible Object Store</div></div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> prend en charge l'emplacement du dépot de sauvegarde dans le magasin d'objet <span class="host">compatible-S3</span>. Le conteneur utilisé pour stocker le dépôt doit être crée à l'avance &mdash; <span class="backrest">pgBackRest</span> il ne se créera donc pas automatiquement. Le dépôt peut être situé à la racine du conteneur (<span class="path">/</span>) mais il est préférable de le pacer dans un sous-chemin afin d'éviter des conflit lors du sockage des traces ou d'autres donnée.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="host">S3</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
process-max=4<br/>
repo1-cipher-pass=zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO<br/>
repo1-cipher-type=aes-256-cbc<br/>
repo1-path=/demo-repo<br/>
repo1-retention-diff=2<br/>
repo1-retention-full=2<br/>
repo1-s3-bucket=demo-bucket<br/>
repo1-s3-endpoint=s3.us-east-1.amazonaws.com<br/>
repo1-s3-key=accessKey1<br/>
repo1-s3-key-secret=verySecretKey1<br/>
repo1-s3-region=us-east-1<br/>
repo1-type=s3<br/>
start-fast=y<br/>
<br/>
[global:archive-push]<br/>
compress-level=3</div></div></div><div class="admonition"><div class="note">NOTE:</div><div class="note-text">La region et le <q>endpoint</q> devront être configurés en fonction de l'endroit où se trouve le conteneur. Les valeurs données ici sont pour la région <span class="id">us-east-1</span>.</div></div><div class="section-body-text">Un rôle doit être créé pour exécuter <span class="backrest">pgBackRest</span> et les permissions du <q>bucket</q> doivent être définies de manière aussi restrictive que possible. Cet exemple de politique <span class="host">Amazon S3</span> restreindra toutes les lectures et écritures dans la zone de stockage et le chemin du dépôt.</div><pre class="code-block">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::demo-bucket"
            ],
            "Condition": {
                "StringEquals": {
                    "s3:prefix": [
                        "",
                        "demo-repo"
                    ],
                    "s3:delimiter": [
                        "/"
                    ]
                }
            }
        },
        {
            "Effect": "Allow",
            "Action": [
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::demo-bucket"
            ],
            "Condition": {
                "StringLike": {
                    "s3:prefix": [
                        "demo-repo/*"
                    ]
                }
            }
        },
        {
            "Effect": "Allow",
            "Action": [
                "s3:PutObject",
                "s3:GetObject",
                "s3:DeleteObject"
            ],
            "Resource": [
                "arn:aws:s3:::demo-bucket/demo-repo/*"
            ]
        }
    ]
}</pre><div class="section-body-text">Les commandes sont exécutées exactement comme si le dépôt était stocké sur un disque local.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Create the stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info stanza-create</pre><pre class="execute-body-output">P00   INFO: stanza-create command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/demo-repo --repo1-s3-bucket=demo-bucket --repo1-s3-endpoint=s3.us-east-1.amazonaws.com --repo1-s3-key=<redacted> --repo1-s3-key-secret=<redacted> --repo1-s3-region=us-east-1 --repo1-type=s3 --stanza=demo
P00   INFO: http statistics: objects 2, sessions 2, requests 12, retries 0, closes 0</pre><pre class="execute-body-output-highlight">P00   INFO: stanza-create command end: completed successfully</pre></div></div><div class="section-body-text">Le temps de création des fichiers dans les magasins d'objets est relativement lent, les commandes bénéficient donc d'une augmentation de <span class="br-option">process-max</span> pour paralléliser la création des fichiers.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Sauvegarder l'instance demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo \
       --log-level-console=info backup</pre><pre class="execute-body-output">P00   INFO: backup command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=4 --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/demo-repo --repo1-retention-diff=2 --repo1-retention-full=2 --repo1-s3-bucket=demo-bucket --repo1-s3-endpoint=s3.us-east-1.amazonaws.com --repo1-s3-key=<redacted> --repo1-s3-key-secret=<redacted> --repo1-s3-region=us-east-1 --repo1-type=s3 --stanza=demo --start-fast</pre><pre class="execute-body-output-highlight">P00   WARN: no prior backup exists, incr backup has been changed to full</pre><pre class="execute-body-output">P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000070000000000000018, lsn = 0/18000028
       [filtered 1136 lines of output]
P04   INFO: backup file /var/lib/pgsql/9.6/data/base/1/12312 (0B, 100%)
P02   INFO: backup file /var/lib/pgsql/9.6/data/base/1/12307 (0B, 100%)</pre><pre class="execute-body-output-highlight">P00   INFO: full backup size = 27.9MB</pre><pre class="execute-body-output">P00   INFO: execute non-exclusive pg_stop_backup() and wait for all WAL segments to archive
P00   INFO: backup stop archive = 000000070000000000000018, lsn = 0/18000130
       [filtered 7 lines of output]</pre></div></div></div></div><div class="section1"><a id="delete-stanza"></a><div class="section1-header"><div class="section1-number">13</div><div class="section1-title">Supprimer un stanza</div></div><div class="section-body"><div class="section-body-text">The <span class="cmd">stanza-delete</span> command removes data in the repository associated with a stanza.<div class="admonition"><div class="warning">WARNING:</div><div class="warning-text">Use this command with caution &mdash; it will permanently remove all backups and archives from the <span class="backrest">pgBackRest</span> repository for the specified stanza.</div></div><br/>
To delete a stanza:<br/>
<ul><li>Shut down the <span class="postgres">PostgreSQL</span> cluster associated with the stanza (or use --force to override).</li><li>Run the <span class="cmd">stop</span> command on the repository host.</li><li>Run the <span class="cmd">stanza-delete</span> command on the repository host.</li></ul>Once the command successfully completes, it is the responsibility of the user to remove the stanza from all <span class="backrest">pgBackRest</span> configuration files.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Stopper l'instance <span class="postgres">PostgreSQL</span> à supprimer</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Stopper <span class="backrest">pgBackRest</span> pour le stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info stop</pre><pre class="execute-body-output">P00   INFO: stop command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/demo-repo --repo1-s3-bucket=demo-bucket --repo1-s3-endpoint=s3.us-east-1.amazonaws.com --repo1-s3-key=<redacted> --repo1-s3-key-secret=<redacted> --repo1-s3-region=us-east-1 --repo1-type=s3 --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: stop command end: completed successfully</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Supprimer le stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info stanza-delete</pre><pre class="execute-body-output">P00   INFO: stanza-delete command begin 2.25: --log-level-console=info --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-cipher-pass=<redacted> --repo1-cipher-type=aes-256-cbc --repo1-path=/demo-repo --repo1-s3-bucket=demo-bucket --repo1-s3-endpoint=s3.us-east-1.amazonaws.com --repo1-s3-key=<redacted> --repo1-s3-key-secret=<redacted> --repo1-s3-region=us-east-1 --repo1-type=s3 --stanza=demo
P00   INFO: http statistics: objects 2, sessions 2, requests 15, retries 0, closes 0</pre><pre class="execute-body-output-highlight">P00   INFO: stanza-delete command end: completed successfully</pre></div></div></div></div><div class="section1"><a id="repo-host"></a><div class="section1-header"><div class="section1-number">14</div><div class="section1-title">Hote de référentiel de sauvegarde dédié</div></div><div class="section-body"><div class="section-body-text">La configuration décrite dans section <a href="#quickstart">Déamarrage Rapide</a> convient aux installations simples, mais pour les configurations d'entreprise, il est plus courant d'avoir un hôte <span class="host">repository</span> dédié où sont stockés les sauvegardes et les fichiers d'archive WAL. Cela permet de séparer les sauvegardes et les archives WAL du serveur de base de données, de sorte que les défaillances de l'hôte <span class="host">database</span> ont moins d'impact. Il est toujours judicieux d'utiliser un logiciel de sauvegarde traditionnel pour sauvegarder l'hôte dédié au sauvegarde <span class="host">repository</span>.</div><div class="section-body-text">Sur l'hôte <span class="postgres">PostgreSQL</span>, l'option <span class="br-option">pg1-path</span> doit être le chemin de la grappe PostgreSQL locale et aucune option <span class="br-option">pg1-host</span> ne doit être configurée. Lors de la configuration d'un hôte de dépôt, le fichier de configuration <span class="backrest">pgBackRest</span> doit avoir l'option <span class="br-option">pg-host</span> configurée pour se connecter aux instances primaire et de secours (le cas échéant). L'hôte de dépôt a la seule configuration <span class="backrest">pgBackRest</span> qui doit connaître plus d'un hôte <span class="postgres">PostgreSQL</span>. L'ordre n'a pas d'importance, par exemple pg1-path/pg1-host, pg2-path/pg2-host peut être le primaire ou le secondaire.</div><div class="section2"><a id="repo-host/install"></a><div class="section2-header"><div class="section2-number">14.1</div><div class="section2-title">Installation</div></div><div class="section-body"><div class="section-body-text">Un nouvel hôte nommé <span class="host">repository</span> est créé pour stocker les sauvegardes du cluster.</div><div class="section-body-text">L'utilisateur <span class="user">pgbackrest</span> est créé pour détenir le référentiel <span class="backrest">pgBackRest</span>. Tout utilisateur peut être propriétaire du référentiel mais il est préférable de ne pas utiliser <span class="user">postgres</span> (s'il existe) pour éviter toute confusion.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Create <span class="user">pgbackrest</span> user</div><div class="execute-body"><pre class="execute-body-cmd">sudo groupadd pgbackrest</pre><pre class="execute-body-cmd">sudo adduser -gpgbackrest -n pgbackrest</pre></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> doit être installé à partir d'un paquet ou installé manuellement comme indiqué ci-dessous.</div><div class="execute"><div class="execute-title"><span class="host">build</span> <b>&#x21d2;</b> Installation des dépendances</div><div class="execute-body"><pre class="execute-body-cmd">sudo yum install postgresql-libs</pre></div></div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Copiez les binaires de <span class="backrest">pgBackRest</span> depuis la plateforme de compilation</div><div class="execute-body"><pre class="execute-body-cmd">sudo scp build:/build/pgbackrest-release-2.25/src/pgbackrest /usr/bin</pre><pre class="execute-body-cmd">sudo chmod 755 /usr/bin/pgbackrest</pre></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> nécessite des répertoires pour les traces (logs) et pour la configuration ainsi qu'un fichier de configuration.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Création des répertoires et du fichier de configuration pour <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p -m 770 /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo chown pgbackrest:pgbackrest /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -p /etc/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -p /etc/pgbackrest/conf.d</pre><pre class="execute-body-cmd">sudo touch /etc/pgbackrest/pgbackrest.conf</pre><pre class="execute-body-cmd">sudo chmod 640 /etc/pgbackrest/pgbackrest.conf</pre><pre class="execute-body-cmd">sudo chown pgbackrest:pgbackrest /etc/pgbackrest/pgbackrest.conf</pre></div></div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Création du dépot de sauvegarde pour <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p /var/lib/pgbackrest</pre><pre class="execute-body-cmd">sudo chmod 750 /var/lib/pgbackrest</pre><pre class="execute-body-cmd">sudo chown pgbackrest:pgbackrest /var/lib/pgbackrest</pre></div></div></div></div><div class="section2"><a id="repo-host/setup-ssh"></a><div class="section2-header"><div class="section2-number">14.2</div><div class="section2-title">Configuration de SSH par échange de clés</div></div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> nécessite un configuration de SSH sans mot de passe (par échange de clef) pour permettre la communication entre les hôtes.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Create <span class="host">repository</span> host key pair</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest mkdir -m 750 /home/pgbackrest/.ssh</pre><pre class="execute-body-cmd">sudo -u pgbackrest ssh-keygen -f /home/pgbackrest/.ssh/id_rsa \
       -t rsa -b 4096 -N ""</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Créer sur <span class="host">pg-primary</span> une paire de clef</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres mkdir -m 750 -p /var/lib/pgsql/.ssh</pre><pre class="execute-body-cmd">sudo -u postgres ssh-keygen -f /var/lib/pgsql/.ssh/id_rsa \
       -t rsa -b 4096 -N ""</pre></div></div><div class="section-body-text">Echange de clef entre <span class="host">repository</span> et <span class="host">pg-primary</span>.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Copiez la clef public de <span class="host">pg-primary</span> sur <span class="host">repository</span></div><div class="execute-body"><pre class="execute-body-cmd">(echo -n 'no-agent-forwarding,no-X11-forwarding,no-port-forwarding,' &amp;&amp; \
       echo -n 'command="/usr/bin/pgbackrest ${SSH_ORIGINAL_COMMAND#* }" ' &amp;&amp; \
       sudo ssh root@pg-primary cat /var/lib/pgsql/.ssh/id_rsa.pub) | \
       sudo -u pgbackrest tee -a /home/pgbackrest/.ssh/authorized_keys</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Copiez la clef publique de <span class="host">repository</span> sur <span class="host">pg-primary</span></div><div class="execute-body"><pre class="execute-body-cmd">(echo -n 'no-agent-forwarding,no-X11-forwarding,no-port-forwarding,' &amp;&amp; \
       echo -n 'command="/usr/bin/pgbackrest ${SSH_ORIGINAL_COMMAND#* }" ' &amp;&amp; \
       sudo ssh root@repository cat /home/pgbackrest/.ssh/id_rsa.pub) | \
       sudo -u postgres tee -a /var/lib/pgsql/.ssh/authorized_keys</pre></div></div><div class="section-body-text">Testez que la connexion SSH fonctionne entre <span class="host">repository</span> et <span class="host">pg-primary</span> et vice versa.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Testez la connexon depuis <span class="host">repository</span> vers <span class="host">pg-primary</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest ssh postgres@pg-primary</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Teste de la connexion depuis <span class="host">pg-primary</span> vers <span class="host">repository</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres ssh pgbackrest@repository</pre></div></div><div class="admonition"><div class="note">NOTE:</div><div class="note-text">ssh a été configuré pour permettre uniquement l'exécution de <span class="backrest">pgBackRest</span> via ssh sans mot de passe. Cela renforce la sécurité en cas de détournement de l'un des comptes de service.</div></div></div></div><div class="section2"><a id="repo-host/config"></a><div class="section2-header"><div class="section2-number">14.3</div><div class="section2-title">Configuration</div></div><div class="section-body"><div class="section-body-text">L'hôte <span class="host">repository</span> doit être configuré avec <span class="host">{[hôte-pg1]}</span> hôte/utilisateur et base de données. Le primaire sera configuré comme <span class="id">pg1</span> pour permettre l'ajout d'une instance secondaire plus tard.</div><div class="config"><div class="config-title"><span class="host">repository</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="br-option">pg1-host</span>/<span class="br-option">pg1-host-user</span> et <span class="br-option">pg1-path</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-host=pg-primary<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y</div></div></div><div class="section-body-text">L'hôte de la base de données doit être configuré avec l'hôte/utilisateur du référentiel de sauvegarde <span class="host">repository</span>. La valeur par défaut de l'option <span class="br-option">repo1-host-user</span> est <span class="id">pgbackrest</span>. Si l'utilisateur <span class="id">postgres</span> effectue des restaurations, il est préférable de ne pas l'autoriser à effectuer des sauvegardes. Toutefois, l'utilisateur <span class="id">postgres</span> peut lire directement le dépôt s'il est dans le même groupe que l'utilisateur <span class="id">pgbackrest</span>.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configure <span class="br-option">repo1-host</span>/<span class="br-option">repo1-host-user</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
log-level-file=detail<br/>
repo1-host=repository</div></div></div><div class="section-body-text">Les commandes sont exécutées de la même manière que sur une configuration à hôte unique, sauf que certaines commandes telles que <span class="cmd">backup</span> et <span class="cmd">expire</span> sont exécutées à partir de l'hôte <span class="host">repository</span> au lieu de l'hôte <span class="host">database</span>.</div><div class="section-body-text">Créer le Stanza dans le nouveau dépôt.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Création du stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo stanza-create</pre></div></div><div class="section-body-text">Vérifiez que la configuration est correcte sur les deux hôtes <span class="host">database</span> et <span class="host">repository</span>. Vous trouverez plus d'informations sur la commande <span class="cmd">check</span> dans la section <a href="#quickstart/check-configuration">Contrôle de la configuration</a>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Contrôler la configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo check</pre></div></div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Check the configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo check</pre></div></div></div></div><div class="section2"><a id="repo-host/perform-backup"></a><div class="section2-header"><div class="section2-number">14.4</div><div class="section2-title">Effectuer une sauvegarde</div></div><div class="section-body"><div class="section-body-text">Pour effectuer une sauvegarde de l'instance <span class="postgres">PostgreSQL</span>, lancez <span class="backrest">pgBackRest</span> avec la commande <span class="cmd">backup</span> sur l'hôte <span class="host">repository</span>.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Sauvegarde du cluster demo</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo backup</pre><pre class="execute-body-output">P00   WARN: no prior backup exists, incr backup has been changed to full</pre></div></div><div class="section-body-text">Depuis qu'un nouveau dépôt a été créé sur l'hôte <span class="host">repository</span>, un avertissement concernant le passage de la sauvegarde incrémentalle à une sauvegarde complète a été émis.</div></div></div><div class="section2"><a id="repo-host/perform-restore"></a><div class="section2-header"><div class="section2-number">14.5</div><div class="section2-title">Restauration d'une sauvegarde</div></div><div class="section-body"><div class="section-body-text">Pour effectuer une restauration de l'instance <span class="postgres">PostgreSQL</span>, lancez <span class="backrest">pgBackRest</span> avec la commande <span class="cmd">restore</span> sur l'hôte <span class="host">database</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêter l'instance demo, restaurer et redémarrer <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta restore</pre><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre></div></div></div></div></div></div><div class="section1"><a id="parallel-backup-restore"></a><div class="section1-header"><div class="section1-number">15</div><div class="section1-title">Sauvegarde / Restauration en parallèle</div></div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> offre un traitement parallèle pour améliorer les performances de la compression et du transfert. Le nombre de processus à utiliser pour cette fonction est défini à l'aide de l'option <span class="br-option">--process-max</span>.</div><div class="section-body-text">Il est généralement préférable de ne pas utiliser plus de 25 % des processeurs disponibles pour la commande <span class="cmd">backup</span>. Les sauvegardes n'ont pas besoin de s'exécuter aussi rapidement dans la mesure où elles sont effectuées régulièrement; le processus de sauvegarde ne doit pas avoir d'impact, si possible, sur les performances de la base de données.</div><div class="section-body-text">La commande de restauration peut et doit utiliser toutes les processeurs (CPU) disponibles car pendant une restauration, l'instance <span class="postgres">PostgreSQL</span> est arrêté et il n'y a généralement pas d'autre travail important effectué sur le serveur. Si le serveur contient plusieurs instances <span class="postgres">PostgreSQL</span>, cela doit être pris en compte dans le paramétrage du parallélisme de la restauration.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Effectuer une sauvegarde avec un seul processus</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo --type=full backup</pre></div></div><div class="config"><div class="config-title"><span class="host">repository</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configurer <span class="backrest">pgBackRest</span> pour utiliser plusieurs processus <span class="cmd">backup</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-host=pg-primary<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
process-max=3<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y</div></div></div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Effectuer une sauvegarde avec plusieurs processus</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo --type=full backup</pre></div></div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Obtenir des informations de sauvegarde pour l'instance demo.</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest info</pre><pre class="execute-body-output">stanza: demo
    status: ok
    cipher: none

    db (current)
        wal archive min/max (9.6-1): 00000008000000000000001E/000000080000000000000020

        full backup: 20200408-111119F</pre><pre class="execute-body-output-highlight">            timestamp start/stop: 2020-04-08 11:11:19 / 2020-04-08 11:11:51</pre><pre class="execute-body-output">            wal start/stop: 00000008000000000000001E / 00000008000000000000001E
            database size: 27.9MB, backup size: 27.9MB
            repository size: 3.3MB, repository backup size: 3.3MB

        full backup: 20200408-111153F</pre><pre class="execute-body-output-highlight">            timestamp start/stop: 2020-04-08 11:11:53 / 2020-04-08 11:12:09</pre><pre class="execute-body-output">            wal start/stop: 000000080000000000000020 / 000000080000000000000020
            database size: 27.9MB, backup size: 27.9MB
            repository size: 3.3MB, repository backup size: 3.3MB</pre></div></div><div class="section-body-text">La performance de la dernière sauvegarde devrait être améliorée en utilisant des processus multiples. Pour les très petites sauvegardes, la différence ne sera peut-être pas très visible, mais plus la taille de la base de données augmente, plus le gain en temps est important.</div></div></div><div class="section1"><a id="start-stop"></a><div class="section1-header"><div class="section1-number">16</div><div class="section1-title">Démarrer et arrêter</div></div><div class="section-body"><div class="section-body-text">Il est parfois utile d'éviter que <span class="backrest">pgBackRest</span> ne fonctionne sur un système. Par exemple, lors du passage d'un système primaire à un système de secours, il est préférable d'empêcher <span class="backrest">pgBackRest</span> de fonctionner sur l'ancien système primaire au cas où <span class="postgres">PostgreSQL</span> serait redémarré ou ne pourrait pas être complètement détruit. Cela empêchera également <span class="backrest">pgBackRest</span> de fonctionner avec un lancement par le <span class="id">cron</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Stop the <span class="backrest">pgBackRest</span> services</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest stop</pre></div></div><div class="section-body-text">Les nouveaux processus <span class="backrest">pgBackRest</span> ne fonctionneront plus.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Tentative de sauvegarde</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo backup</pre><pre class="execute-body-output-highlight-error">P00   WARN: unable to check pg-1: [StopError] raised from remote-0 protocol on 'pg-primary': stop file exists for all stanzas</pre><pre class="execute-body-output">P00  ERROR: [056]: unable to find primary cluster - cannot proceed</pre></div></div><div class="section-body-text">Précisez l'option <span class="br-option">--force</span> pour mettre fin à tout processus <span class="backrest">pgBackRest</span> en cours. Si <span class="backrest">pgBackRest</span> est déjà arrêté, un avertissement sera généré si vous l'arrêtez à nouveau.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêter à nouveau les services de <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest stop</pre><pre class="execute-body-output">P00   WARN: stop file already exists for all stanzas</pre></div></div><div class="section-body-text">Démarrer le processus <span class="backrest">pgBackRest</span> à nouveau avec la commande <span class="cmd">start</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Démarrer les services <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest start</pre></div></div><div class="section-body-text">Il est également possible de stopper <span class="backrest">pgBackRest</span> pour une seule stanza.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Stoper le services <span class="backrest">pgBackRest</span> pour le stanza <span class="id">demo</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo stop</pre></div></div><div class="section-body-text">Les nouveaux processus <span class="backrest">pgBackRest</span> pour le stanza spécifiée ne fonctionneront plus.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Tentative de sauvegarde</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo backup</pre><pre class="execute-body-output-highlight-error">P00   WARN: unable to check pg-1: [StopError] raised from remote-0 protocol on 'pg-primary': stop file exists for stanza demo</pre><pre class="execute-body-output">P00  ERROR: [056]: unable to find primary cluster - cannot proceed</pre></div></div><div class="section-body-text">Le stanza doit également être spécifiée lors du lancement des processus <span class="backrest">pgBackRest</span> pour un stanza unique.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Start the <span class="backrest">pgBackRest</span> services for the <span class="id">demo</span> stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo start</pre></div></div></div></div><div class="section1"><a id="replication"></a><div class="section1-header"><div class="section1-number">17</div><div class="section1-title">Replication</div></div><div class="section-body"><div class="section-body-text">La réplication permet de créer plusieurs copies d'une instance <span class="postgres">PostgreSQL</span> (appelé esclave ou standbys) à partir d'une seule primaire. Les standbys sont utiles pour équilibrer les lectures et pour fournir une redondance en cas de défaillance de l'hôte primaire.</div><div class="section2"><a id="replication/installation"></a><div class="section2-header"><div class="section2-number">17.1</div><div class="section2-title">Installation</div></div><div class="section-body"><div class="section-body-text">Un nouvel hôte nommé <span class="host">pg-standby</span> est créé pour ce rôle de standby (esclave).</div><div class="section-body-text"><span class="backrest">pgBackRest</span> doit être installé à partir d'un paquet ou installé manuellement comme indiqué ci-dessous.</div><div class="execute"><div class="execute-title"><span class="host">build</span> <b>&#x21d2;</b> Installation des dépendances</div><div class="execute-body"><pre class="execute-body-cmd">sudo yum install postgresql-libs</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Copiez les binaires de <span class="backrest">pgBackRest</span> depuis la plateforme de compilation</div><div class="execute-body"><pre class="execute-body-cmd">sudo scp build:/build/pgbackrest-release-2.25/src/pgbackrest /usr/bin</pre><pre class="execute-body-cmd">sudo chmod 755 /usr/bin/pgbackrest</pre></div></div><div class="section-body-text"><span class="backrest">pgBackRest</span> nécessite des répertoires pour les traces (logs) et pour la configuration ainsi qu'un fichier de configuration.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Création des répertoires et du fichier de configuration pour <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p -m 770 /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/log/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -p /etc/pgbackrest</pre><pre class="execute-body-cmd">sudo mkdir -p /etc/pgbackrest/conf.d</pre><pre class="execute-body-cmd">sudo touch /etc/pgbackrest/pgbackrest.conf</pre><pre class="execute-body-cmd">sudo chmod 640 /etc/pgbackrest/pgbackrest.conf</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /etc/pgbackrest/pgbackrest.conf</pre></div></div></div></div><div class="section2"><a id="replication/setup-ssh"></a><div class="section2-header"><div class="section2-number">17.2</div><div class="section2-title">Configurer un accès SSH sans mot de passe</div></div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> nécessite un configuration de SSH sans mot de passe (par échange de clef) pour permettre la communication entre les hôtes.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Créer sur <span class="host">pg-standby</span> une paire de clef</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres mkdir -m 750 -p /var/lib/pgsql/.ssh</pre><pre class="execute-body-cmd">sudo -u postgres ssh-keygen -f /var/lib/pgsql/.ssh/id_rsa \
       -t rsa -b 4096 -N ""</pre></div></div><div class="section-body-text">Echange de clef entre <span class="host">repository</span> et <span class="host">pg-standby</span>.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Copiez la clef public de <span class="host">pg-standby</span> sur <span class="host">repository</span></div><div class="execute-body"><pre class="execute-body-cmd">(echo -n 'no-agent-forwarding,no-X11-forwarding,no-port-forwarding,' &amp;&amp; \
       echo -n 'command="/usr/bin/pgbackrest ${SSH_ORIGINAL_COMMAND#* }" ' &amp;&amp; \
       sudo ssh root@pg-standby cat /var/lib/pgsql/.ssh/id_rsa.pub) | \
       sudo -u pgbackrest tee -a /home/pgbackrest/.ssh/authorized_keys</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Copiez la clef publique de <span class="host">repository</span> sur <span class="host">pg-standby</span></div><div class="execute-body"><pre class="execute-body-cmd">(echo -n 'no-agent-forwarding,no-X11-forwarding,no-port-forwarding,' &amp;&amp; \
       echo -n 'command="/usr/bin/pgbackrest ${SSH_ORIGINAL_COMMAND#* }" ' &amp;&amp; \
       sudo ssh root@repository cat /home/pgbackrest/.ssh/id_rsa.pub) | \
       sudo -u postgres tee -a /var/lib/pgsql/.ssh/authorized_keys</pre></div></div><div class="section-body-text">Testez que la connexion SSH fonctionne entre <span class="host">repository</span> et <span class="host">pg-standby</span> et vice versa.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Testez la connexon depuis <span class="host">repository</span> vers <span class="host">pg-standby</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest ssh postgres@pg-standby</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Teste de la connexion depuis <span class="host">pg-standby</span> vers <span class="host">repository</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres ssh pgbackrest@repository</pre></div></div></div></div><div class="section2"><a id="replication/hot-standby"></a><div class="section2-header"><div class="section2-number">17.3</div><div class="section2-title">Hot Standby</div></div><div class="section-body"><div class="section-body-text">Un <q>hot standby</q> effectue la réplication en utilisant l'archive WAL et permet des requêtes en lecture seule.</div><div class="section-body-text">La configuration de <span class="backrest">pgBackRest</span> est très similaire à celle de <span class="host">pg-primary</span> sauf que le type de récupération <span class="id">standby</span> sera utilisé pour maintenir l'instance en mode de récupération lorsque la fin du flux WAL aura été atteinte.</div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="backrest">pgBackRest</span> sur l'escalve (standby)</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
log-level-file=detail<br/>
repo1-host=repository</div></div></div><div class="section-body-text">Créez le répertoire où <span class="postgres">PostgreSQL</span> sera restauré.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Création du répertoire pour <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres mkdir -p -m 700 /var/lib/pgsql/9.6/data</pre></div></div><div class="section-body-text">Maintenant, l'escalve (standby) peut être créée avec la commande <span class="cmd">restore</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Restaurer le demo l'instance esclave (standby)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=standby restore</pre><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/recovery.conf</pre><pre class="execute-body-output"># Recovery settings generated by pgBackRest restore on 2020-04-08 11:12:42
restore_command = 'pgbackrest --stanza=demo archive-get %f "%p"'
standby_mode = 'on'</pre></div></div><div class="section-body-text">Le paramètre <span class="pg-setting">hot_standby</span> doit être activé avant de lancer <span class="postgres">PostgreSQL</span> pour autoriser les connexions en lecture seule sur <span class="host">pg-standby</span>. Dans le cas contraire, les tentatives de connexion seront refusées. Le reste de la configuration concerne le cas où l'instance esclave (standby) est promue comme primaire.</div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/var/lib/pgsql/9.6/data/postgresql.conf</span> <b>&#x21d2;</b> Configuration de <span class="postgres">PostgreSQL</span></div><div class="config-body"><div class="config-body-output">archive_command = 'pgbackrest --stanza=demo archive-push %p'<br/>
archive_mode = on<br/>
hot_standby = on<br/>
log_filename = 'postgresql.log'<br/>
log_line_prefix = ''<br/>
max_wal_senders = 3<br/>
wal_level = replica</div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Démarrage de <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre></div></div><div class="section-body-text">Le journal des traces <span class="postgres">PostgreSQL</span> donne des informations précieuses sur la récupération. Notez en particulier que l'instance est entré en mode veille et est prête à accepter des connexions en lecture seule.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Examiner la sortie du journal de traces <span class="postgres">PostgreSQL</span> à la recherche des messages indiquant le succès</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/pg_log/postgresql.log</pre><pre class="execute-body-output">LOG:  database system was interrupted; last known up at 2020-04-08 11:11:54 UTC</pre><pre class="execute-body-output-highlight">LOG:  entering standby mode</pre><pre class="execute-body-output">LOG:  restored log file "00000008.history" from archive
LOG:  restored log file "000000080000000000000020" from archive
LOG:  redo starts at 0/20000028
LOG:  consistent recovery state reached at 0/20000130</pre><pre class="execute-body-output-highlight">LOG:  database system is ready to accept read only connections</pre></div></div><div class="section-body-text">Une façon simple de vérifier que la réplication est correctement configurée est de créer une table sur <span class="host">pg-primary</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Créer une nouvelle table sur l'instance primaire</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       begin; \
       create table replicated_table (message text); \
       insert into replicated_table values ('Important Data'); \
       commit; \
       select * from replicated_table";</pre><pre class="execute-body-output">    message     
----------------</pre><pre class="execute-body-output-highlight"> Important Data</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">Puis interrogez la même table sur <span class="host">pg-standby</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Intérroger la nouvelle table sur l'esclave (standby)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select * from replicated_table;"</pre><pre class="execute-body-output-highlight-error">ERROR:  relation "replicated_table" does not exist</pre><pre class="execute-body-output">LINE 1: select * from replicated_table;
                      ^</pre></div></div><div class="section-body-text">Alors, qu'est-ce qui a mal tourné ? Puisque <span class="postgres">PostgreSQL</span> extrait des segments WAL de l'archive pour effectuer la réplication, les changements ne seront pas visibles en attente jusqu'à ce que le segment WAL qui contient ces changements soit poussé de <span class="host">pg-primary</span>.</div><div class="section-body-text">Cela peut être fait manuellement en appelant <span class="id">pg_switch_xlog()</span> qui pousse le segment WAL actuel vers l'archive (un nouveau segment WAL est créé pour contenir les nouveaux changements).</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Executer <span class="id">pg_switch_xlog()</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "select *, current_timestamp from pg_switch_xlog()";</pre><pre class="execute-body-output"> pg_switch_xlog |             now              
----------------+------------------------------
 0/210219C0     | 2020-04-08 11:12:51.05241+00
(1 row)</pre></div></div><div class="section-body-text">Maintenant, après un court délai, la table apparaîtra sur <span class="host">pg-standby</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> La nouvelle table existe maintenant sur l'esclave (standby) (peut nécessiter quelques essais)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       select *, current_timestamp from replicated_table"</pre><pre class="execute-body-output">    message     |              now              
----------------+-------------------------------</pre><pre class="execute-body-output-highlight"> Important Data | 2020-04-08 11:12:53.160678+00</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="section-body-text">Vérifiez la configuration de l'esclave pour l'accès au dépôt de sauvegarde.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Contrôle de la configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info check</pre><pre class="execute-body-output">P00   INFO: check command begin 2.25: --log-level-console=info --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-host=repository --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: switch wal not performed because this is a standby</pre><pre class="execute-body-output">P00   INFO: check command end: completed successfully</pre></div></div></div></div><div class="section2"><a id="replication/streaming"></a><div class="section2-header"><div class="section2-number">17.4</div><div class="section2-title">Réplication en flux contrinu flux (streaming replication)</div></div><div class="section-body"><div class="section-body-text">Au lieu de s'appuyer uniquement sur les archives de la WAL, la réplication en continu établit une connexion directe avec l'instance primaire et applique les modifications dès qu'elles sont effectuées sur la primaire. Il en résulte un délai beaucoup plus court entre le primaire et le secondaire (standby).</div><div class="section-body-text">La réplication en continu nécessite un utilisateur disposant du privilège de réplication.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création d'un utilisateur de réplication</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       create user replicator password 'jw8s0F4' replication";</pre><pre class="execute-body-output">CREATE ROLE</pre></div></div><div class="section-body-text">Le fichier <span class="file">pg_hba.conf</span> doit être mis à jour afin de permettre à l'utilisateur de réplication utilisé sur l'instance esclave (standby) de se connecter. Veillez à remplacer l'adresse IP ci-dessous par l'adresse IP réelle de votre <span class="host">pg-primary</span>. Un rechargement (reload) sera nécessaire après la modification du fichier <span class="file">pg_hba.conf</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création de l'entrée pour l'utilisateur de réplication dans <span class="file">pg_hba.conf</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres sh -c 'echo \
       "host    replication     replicator      172.17.0.6/32           md5" \
       >> /var/lib/pgsql/9.6/data/pg_hba.conf'</pre><pre class="execute-body-cmd">sudo systemctl reload postgresql-9.6.service</pre></div></div><div class="section-body-text">L'instance esclave (standby) doit savoir comment se connecter à l'instance primaire, pour ce faire, il faut configurer le paramètre <span class="pg-option">primary_conninfo</span> dans <span class="backrest">pgBackRest</span>.</div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Paramètrage de <span class="pg-option">primary_conninfo</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
recovery-option=primary_conninfo=host=172.17.0.4 port=5432 user=replicator<br/>
<br/>
[global]<br/>
log-level-file=detail<br/>
repo1-host=repository</div></div></div><div class="section-body-text">Il est possible de configurer un mot de passe pour le paramètre <span class="pg-option">primary_conninfo</span> mais l'utilisation d'un fichier <span class="file">.pgpass</span> est plus souple et plus sûre.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Configurez le mot de passe de réplication dans le fichier <span class="file">.pgpass</span>.</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres sh -c 'echo \
       "172.17.0.4:*:replication:replicator:jw8s0F4" \
       >> /var/lib/pgsql/.pgpass'</pre><pre class="execute-body-cmd">sudo -u postgres chmod 600 /var/lib/pgsql/.pgpass</pre></div></div><div class="section-body-text">Maintenant, l'instance esclave (standby) peut être créée avec la commande <span class="cmd">restore</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Arrêter <span class="postgres">PostgreSQL</span> et restaurer l'instance demo esclave (standby)</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --delta --type=standby restore</pre><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/recovery.conf</pre><pre class="execute-body-output"># Recovery settings generated by pgBackRest restore on 2020-04-08 11:13:00
primary_conninfo = 'host=172.17.0.4 port=5432 user=replicator'
restore_command = 'pgbackrest --stanza=demo archive-get %f "%p"'
standby_mode = 'on'</pre></div></div><div class="admonition"><div class="note">NOTE:</div><div class="note-text">Le paramètre <span class="pg-setting">primary_conninfo</span> a été écrit dans le fichier <span class="file">recovery.conf</span>. La configuration des paramètres de récupération dans <span class="backrest">pgBackRest</span> signifie que le fichier <span class="file">recovery.conf</span> n'a pas besoin d'être stocké ailleurs puisqu'il sera correctement recréé à chaque restauration. L'option <span class="br-setting">--type=preserve</span> peut être utilisée avec le <span class="cmd">restore</span> pour laisser le fichier <span class="file">recovery.conf</span> existant en place si ce comportement est préféré.</div></div><div class="section-body-text">Par défaut, RHEL/CentOS 7 stocke le fichier <span class="file">postgresql.conf</span> dans le répertoire <span class="postgres">PostgreSQL</span> data. Cela signifie que la modification apportée au fichier <span class="file">postgresql.conf</span> seront écrasées par la dernière restauration et que le paramètre <span class="pg-option">hot_standby</span> doit être réactivé. Les autres solutions à ce problème consistent à stocker le fichier <span class="file">postgresql.conf</span> ailleurs ou à activer le paramètre <span class="pg-option">hot_standby</span> sur l'hôte <span class="host">pg-primary</span> où il sera ignoré.</div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/var/lib/pgsql/9.6/data/postgresql.conf</span> <b>&#x21d2;</b> Activation de <span class="pg-option">hot_standby</span></div><div class="config-body"><div class="config-body-output">archive_command = 'pgbackrest --stanza=demo archive-push %p'<br/>
archive_mode = on<br/>
hot_standby = on<br/>
log_filename = 'postgresql.log'<br/>
log_line_prefix = ''<br/>
max_wal_senders = 3<br/>
wal_level = replica</div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Démarrage de <span class="postgres">PostgreSQL</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-9.6.service</pre></div></div><div class="section-body-text">Le journal de traces <span class="postgres">PostgreSQL</span> confirmera que la réplication en mode flux continue (streaming réplication) a commencé.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Examen de la sortie des traces <span class="postgres">PostgreSQL</span> à la recherche des messages indiquant le succès</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/lib/pgsql/9.6/data/pg_log/postgresql.log</pre><pre class="execute-body-output">       [filtered 6 lines of output]
LOG:  database system is ready to accept read only connections
LOG:  restored log file "000000080000000000000021" from archive</pre><pre class="execute-body-output-highlight">LOG:  started streaming WAL from primary at 0/22000000 on timeline 8</pre></div></div><div class="section-body-text">Désormais, lorsqu'une table est créé esur <span class="host">pg-primary</span>, il apparaîtra sur <span class="host">pg-standby</span> rapidement et sans qu'il soit nécessaire d'appeler la fonction SQL <span class="id">pg_switch_xlog()</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Création d'une nouvelle table sur le primaire</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       begin; \
       create table stream_table (message text); \
       insert into stream_table values ('Important Data'); \
       commit; \
       select *, current_timestamp from stream_table";</pre><pre class="execute-body-output">    message     |              now              
----------------+-------------------------------</pre><pre class="execute-body-output-highlight"> Important Data | 2020-04-08 11:13:07.493668+00</pre><pre class="execute-body-output">(1 row)</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Intéroger la table sur l'esclave (standby)</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       select *, current_timestamp from stream_table"</pre><pre class="execute-body-output">    message     |             now             
----------------+-----------------------------</pre><pre class="execute-body-output-highlight"> Important Data | 2020-04-08 11:13:08.1841+00</pre><pre class="execute-body-output">(1 row)</pre></div></div></div></div></div></div><div class="section1"><a id="async-archiving"></a><div class="section1-header"><div class="section1-number">18</div><div class="section1-title">Archivage asynchrone</div></div><div class="section-body"><div class="section-body-text">L'archivage asynchrone est activé avec l'option <span class="br-option">archive-async</span>. Cette option permet un fonctionnement asynchrone pour les commandes <span class="cmd">archive-push</span> et <span class="cmd">archive-get</span>.</div><div class="section-body-text">Un chemin de file d'attente (spool) est nécessaire. Les commandes stockent les données transitoires ici, mais chaque commande fonctionne de manière distincte, de sorte que l'utilisation du chemin d'accès à la file d'attente (spool) est décrite en détail dans chaque section.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Créer le répertoire de file d'attente (spool)</div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p -m 750 /var/spool/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/spool/pgbackrest</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Créer le répertoire de file d'attente (spool)</div><div class="execute-body"><pre class="execute-body-cmd">sudo mkdir -p -m 750 /var/spool/pgbackrest</pre><pre class="execute-body-cmd">sudo chown postgres:postgres /var/spool/pgbackrest</pre></div></div><div class="section-body-text">Le chemin de la file d'attente (spool) doit être configuré et l'archivage asynchrone activé. L'archivage asynchrone apporte automatiquement un intérêt en réduisant le nombre de connexions au stockage distant, mais le réglage de <span class="br-option">process-max</span> peut permettre d'améliorer considérablement les performances en parallélisant les opérations. Assurez-vous de ne pas régler <span class="br-option">process-max</span> à un niveau si élevé qu'il affecte les opérations normales de la base de données.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configurer le chemin du spool et l'archivage asynchrone</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
archive-async=y<br/>
log-level-file=detail<br/>
repo1-host=repository<br/>
spool-path=/var/spool/pgbackrest<br/>
<br/>
[global:archive-get]<br/>
process-max=2<br/>
<br/>
[global:archive-push]<br/>
process-max=2</div></div></div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configurer le chemin du spool et l'archivage asynchrone</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
recovery-option=primary_conninfo=host=172.17.0.4 port=5432 user=replicator<br/>
<br/>
[global]<br/>
archive-async=y<br/>
log-level-file=detail<br/>
repo1-host=repository<br/>
spool-path=/var/spool/pgbackrest<br/>
<br/>
[global:archive-get]<br/>
process-max=2<br/>
<br/>
[global:archive-push]<br/>
process-max=2</div></div></div><div class="admonition"><div class="note">NOTE:</div><div class="note-text"><span class="br-option">process-max</span> est configuré à l'aide de sections de commande de sorte que l'option ne soit pas utilisée par la sauvegarde et la restauration. Cela permet également d'utiliser des valeurs différentes pour <span class="cmd">archive-push</span> et <span class="cmd">archive-get</span>.</div></div><div class="section-body-text">A des fins de démonstration, la réplication du streaming sera interrompue pour forcer <span class="postgres">PostgreSQL</span> à obtenir le WAL en utilisant la <span class="pg-option">restore_command</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Interrompre la réplication du streaming en changeant le mot de passe de la réplication</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "alter user replicator password 'bogus'"</pre><pre class="execute-body-output">ALTER ROLE</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Redémarrer l'esclave (standby) pour interrompre la connexion</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl restart postgresql-9.6.service</pre></div></div><div class="section2"><a id="async-archiving/async-archive-push"></a><div class="section2-header"><div class="section2-number">18.1</div><div class="section2-title">Poussez les archives (Archive Push)</div></div><div class="section-body"><div class="section-body-text">La commande asynchrone <span class="cmd">archive-push</span> décharge l'archivage WAL vers un (ou plusieurs) processus séparé(s) pour améliorer le débit. Elle fonctionne <q>en regardant vers l'avenir</q> pour voir quels segments WAL sont prêts à être archivés au-delà de la demande que <span class="postgres">PostgreSQL</span> fait actuellement via la commande <span class="id">archive_command</span>. Les segments WAL sont transférés vers archivage directement depuis le répertoire <span class="path">pg_xlog</span>/<span class="path">pg_wal</span> et le retour de succès n'est renvoyé par l' <span class="id">archive_command</span> que lorsque le segment WAL est réelement stocké en toute sécurité dans l'archivage.</div><div class="section-body-text">La file d'attente (spool) contient l'état actuel de l'archivage des WAL. Les fichiers d'état écrits dans le répertoire de spool sont généralement de longueur zéro et devraient consommer un minimum d'espace (quelques Mo au maximum) et très peu d'E/S. Toutes les informations contenues dans ce répertoire peuvent être recréées, il n'est donc pas nécessaire de le préserver si l'instance est déplacé vers un nouveau matériel.</div><div class="admonition"><div class="important">IMPORTANT:</div><div class="important-text">Dans l'implémentation initiale de l'archivage asynchrone, les segments WAL étaient copiés dans le répertoire spool avant la compression et le transfert. La nouvelle implémentation copie le WAL directement à partir du répertoire <span class="path">pg_xlog</span>. Si l'archivage asynchrone était utilisé dans <span class="host">v1.12</span> ou antérieur, lisez attentivement les notes de mise à jour de <span class="host">v1.13</span> avant de procéder à la mise à niveau.</div></div><div class="section-body-text">Le fichier <span class="file">[stanza]-archive-push-async.log</span> peut être utilisé pour surveiller l'activité du processus asynchrone. Une bonne façon de tester cela est de pousser rapidement un certain nombre de segments WAL.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Tester l'archivage asynchrone parallèle</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c " \
       select pg_create_restore_point('test async push'); select pg_switch_xlog(); \
       select pg_create_restore_point('test async push'); select pg_switch_xlog(); \
       select pg_create_restore_point('test async push'); select pg_switch_xlog(); \
       select pg_create_restore_point('test async push'); select pg_switch_xlog(); \
       select pg_create_restore_point('test async push'); select pg_switch_xlog();"</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --log-level-console=info check</pre><pre class="execute-body-output">P00   INFO: check command begin 2.25: --log-level-console=info --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --repo1-host=repository --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: WAL segment 000000080000000000000027 successfully archived to '/var/lib/pgbackrest/archive/demo/9.6-1/0000000800000000/000000080000000000000027-a8aeb2cafd81e4f64859c9069412aa7d6fce4916.gz'</pre><pre class="execute-body-output">P00   INFO: check command end: completed successfully</pre></div></div><div class="section-body-text">Le fichier journal (traces) contiendra désormais les activités parallèles et asynchrones.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Vérifier les résultats dans les traces.</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/pgbackrest/demo-archive-push-async.log</pre><pre class="execute-body-output">-------------------PROCESS START-------------------
P00   INFO: archive-push:async command begin 2.25: [/var/lib/pgsql/9.6/data/pg_xlog] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: push 1 WAL file(s) to archive: 000000080000000000000022
P01 DETAIL: pushed WAL file '000000080000000000000022' to the archive</pre><pre class="execute-body-output">P00   INFO: archive-push:async command end: completed successfully

-------------------PROCESS START-------------------
P00   INFO: archive-push:async command begin 2.25: [/var/lib/pgsql/9.6/data/pg_xlog] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: push 1 WAL file(s) to archive: 000000080000000000000023
P01 DETAIL: pushed WAL file '000000080000000000000023' to the archive</pre><pre class="execute-body-output">P00   INFO: archive-push:async command end: completed successfully

-------------------PROCESS START-------------------
P00   INFO: archive-push:async command begin 2.25: [/var/lib/pgsql/9.6/data/pg_xlog] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: push 2 WAL file(s) to archive: 000000080000000000000024...000000080000000000000025
P02 DETAIL: pushed WAL file '000000080000000000000025' to the archive
P01 DETAIL: pushed WAL file '000000080000000000000024' to the archive</pre><pre class="execute-body-output">P00   INFO: archive-push:async command end: completed successfully

-------------------PROCESS START-------------------
P00   INFO: archive-push:async command begin 2.25: [/var/lib/pgsql/9.6/data/pg_xlog] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: push 1 WAL file(s) to archive: 000000080000000000000026
P01 DETAIL: pushed WAL file '000000080000000000000026' to the archive</pre><pre class="execute-body-output">P00   INFO: archive-push:async command end: completed successfully

-------------------PROCESS START-------------------
P00   INFO: archive-push:async command begin 2.25: [/var/lib/pgsql/9.6/data/pg_xlog] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: push 1 WAL file(s) to archive: 000000080000000000000027
P01 DETAIL: pushed WAL file '000000080000000000000027' to the archive</pre><pre class="execute-body-output">P00   INFO: archive-push:async command end: completed successfully</pre></div></div></div></div><div class="section2"><a id="async-archiving/async-archive-get"></a><div class="section2-header"><div class="section2-number">18.2</div><div class="section2-title">Obtention des archives (archive-get)</div></div><div class="section-body"><div class="section-body-text">La commande asynchrone <span class="cmd">archive-get</span> maintient une file d'attente locale de WAL pour améliorer le débit. Si un segment de WAL n'est pas trouvé dans la file d'attente, il est récupéré dans le dépôt avec suffisamment de WAL consécutifs pour remplir la file d'attente. La taille maximale de la file d'attente est définie par la commande <span class="br-option">archive-get-queue-max</span>. Lorsque la file d'attente est moins de la moitié de sa capacité, un nombre plus important de WAL sera récupéré pour la remplir.</div><div class="section-body-text">Ce fonctionnement asynchrone est utile dans les environnements qui génèrent beaucoup de WAL ou qui ont une connexion à haute latence avec le stockage du dépôt (par exemple <span class="host">S3</span> ou d'autres magasins d'objets). Dans le cas d'une connexion à forte latence, il peut être judicieux d'augmenter <span class="br-option">process-max</span>.</div><div class="section-body-text">Le fichier <span class="file">[stanza]-archive-get-async.log</span> est utilisé pour surveiller l'activité du processus asynchrone.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Vérifier les résultats dans le journal des traces</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres cat /var/log/pgbackrest/demo-archive-get-async.log</pre><pre class="execute-body-output">-------------------PROCESS START-------------------
P00   INFO: archive-get:async command begin 2.25: [000000080000000000000020, 000000080000000000000021, 000000080000000000000022, 000000080000000000000023, 000000080000000000000024, 000000080000000000000025, 000000080000000000000026, 000000080000000000000027] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo
P00   INFO: get 8 WAL file(s) from archive: 000000080000000000000020...000000080000000000000027</pre><pre class="execute-body-output-highlight">P01 DETAIL: found 000000080000000000000020 in the archive
P02 DETAIL: found 000000080000000000000021 in the archive</pre><pre class="execute-body-output">P01 DETAIL: unable to find 000000080000000000000022 in the archive
P02 DETAIL: unable to find 000000080000000000000023 in the archive
       [filtered 20 lines of output]
P00   INFO: archive-get:async command begin 2.25: [000000080000000000000022, 000000080000000000000023, 000000080000000000000024, 000000080000000000000025, 000000080000000000000026, 000000080000000000000027, 000000080000000000000028, 000000080000000000000029] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo
P00   INFO: get 8 WAL file(s) from archive: 000000080000000000000022...000000080000000000000029</pre><pre class="execute-body-output-highlight">P01 DETAIL: found 000000080000000000000022 in the archive
P02 DETAIL: found 000000080000000000000023 in the archive</pre><pre class="execute-body-output">P01 DETAIL: unable to find 000000080000000000000024 in the archive
P02 DETAIL: unable to find 000000080000000000000025 in the archive
       [filtered 7 lines of output]
P00   INFO: archive-get:async command begin 2.25: [000000080000000000000024, 000000080000000000000025, 000000080000000000000026, 000000080000000000000027, 000000080000000000000028, 000000080000000000000029, 00000008000000000000002A, 00000008000000000000002B] --archive-async --log-level-console=off --log-level-file=detail --log-level-stderr=off --no-log-timestamp --pg1-path=/var/lib/pgsql/9.6/data --process-max=2 --repo1-host=repository --spool-path=/var/spool/pgbackrest --stanza=demo
P00   INFO: get 8 WAL file(s) from archive: 000000080000000000000024...00000008000000000000002B</pre><pre class="execute-body-output-highlight">P02 DETAIL: found 000000080000000000000025 in the archive
P01 DETAIL: found 000000080000000000000024 in the archive</pre><pre class="execute-body-output">P01 DETAIL: unable to find 000000080000000000000027 in the archive
P01 DETAIL: unable to find 000000080000000000000028 in the archive</pre><pre class="execute-body-output-highlight">P02 DETAIL: found 000000080000000000000026 in the archive</pre><pre class="execute-body-output">P01 DETAIL: unable to find 000000080000000000000029 in the archive
P01 DETAIL: unable to find 00000008000000000000002A in the archive
       [filtered 23 lines of output]
P02 DETAIL: unable to find 00000008000000000000002C in the archive
P02 DETAIL: unable to find 00000008000000000000002D in the archive</pre><pre class="execute-body-output-highlight">P01 DETAIL: found 000000080000000000000027 in the archive</pre><pre class="execute-body-output">P02 DETAIL: unable to find 00000008000000000000002E in the archive
P00   INFO: archive-get:async command end: completed successfully</pre></div></div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Régler le problème de la réplication par flux (streaming replication) en rechangeant le mot de passe de la réplication</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres psql -c "alter user replicator password 'jw8s0F4'"</pre><pre class="execute-body-output">ALTER ROLE</pre></div></div></div></div><div class="section1"><a id="standby-backup"></a><div class="section1-header"><div class="section1-number">19</div><div class="section1-title">Sauvegarde depuis l'esclave (standby)</div></div><div class="section-body"><div class="section-body-text"><span class="backrest">pgBackRest</span> peut effectuer des sauvegardes depuis l'esclave (standby) au lieu de la sauvegarde depuis le primaire. Les sauvegardes en attente nécessitent que l'hôte <span class="host">pg-standby</span> soit configuré et que l'option <span class="br-option">backup-standby</span> soit activée. Si plus d'une instance esclave (standby) est configuré, c'est le premier en cours d'exécution trouvé qui sera utilisé pour la sauvegarde.</div><div class="config"><div class="config-title"><span class="host">repository</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Configuration de <span class="br-option">pg2-host</span>/<span class="br-option">pg2-host-user</span> et <span class="br-option">pg2-path</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-host=pg-primary<br/>
pg1-path=/var/lib/pgsql/9.6/data<br/>
pg2-host=pg-standby<br/>
pg2-path=/var/lib/pgsql/9.6/data<br/>
<br/>
[global]<br/>
backup-standby=y<br/>
process-max=3<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y</div></div></div><div class="section-body-text">L'instance primaire et esclave (standby) sont toutes les deux nécessaires pour effectuer la sauvegarde, bien que la grande majorité des fichiers soient copiés à partir d'instance esclave afin de réduire la charge sur l'instance primaire. Les instances de la base de données peuvent être configurés dans n'importe quel ordre. <span class="backrest">pgBackRest</span> déterminera automatiquement quelle est l'instance primaire et quelle est l'instance secondaire (standby).</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Sauvegarde de l'instance demo depuis <span class="host">pg2</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo --log-level-console=detail backup</pre><pre class="execute-body-output">       [filtered 2 lines of output]
P00   INFO: execute non-exclusive pg_start_backup(): backup begins after the requested immediate checkpoint completes
P00   INFO: backup start archive = 000000080000000000000029, lsn = 0/29000028</pre><pre class="execute-body-output-highlight">P00   INFO: wait for replay on the standby to reach 0/29000028
P00   INFO: replay on the standby reached 0/29000028
P01   INFO: backup file pg-primary:/var/lib/pgsql/9.6/data/pg_log/postgresql.log (8.1KB, 0%) checksum 16f66c054fc1d8195e5340e08d69e505465ffb25</pre><pre class="execute-body-output">P03   INFO: backup file pg-standby:/var/lib/pgsql/9.6/data/base/12470/1249 (360KB, 16%) checksum ed7368dfd9b69a70716891bfa6f74373e31ca0b2</pre><pre class="execute-body-output-highlight">P01   INFO: backup file pg-primary:/var/lib/pgsql/9.6/data/global/pg_control (8KB, 17%) checksum c15306a6ce60bc9289e9612f28701ac2775f3d44</pre><pre class="execute-body-output">P02   INFO: backup file pg-standby:/var/lib/pgsql/9.6/data/base/12470/2608 (440KB, 37%) checksum d9a663a3230385c82c6fb8ab0f1a491d20c57585
P04   INFO: backup file pg-standby:/var/lib/pgsql/9.6/data/base/12470/2674 (344KB, 52%) checksum b59efe2235645def556af811c49b987490a5d114
P03   INFO: backup file pg-standby:/var/lib/pgsql/9.6/data/base/12470/2673 (336KB, 67%) checksum 39f6a1778c140472056a9e490e201eb0a658e641</pre><pre class="execute-body-output-highlight">P01   INFO: backup file pg-primary:/var/lib/pgsql/9.6/data/pg_hba.conf (4.2KB, 68%) checksum 1c0bca2f7f44d354aaaefb2c21fd1290b7379690</pre><pre class="execute-body-output">P02   INFO: backup file pg-standby:/var/lib/pgsql/9.6/data/base/12470/2658 (104KB, 72%) checksum d73eb8279d55aad9a9f380b4a90dc08754ab6fbf
P04   INFO: backup file pg-standby:/var/lib/pgsql/9.6/data/base/12470/1259 (88KB, 76%) checksum fc0f4be5d31138eba32bb43d30662ba778408f67
       [filtered 1145 lines of output]</pre></div></div><div class="section-body-text">Cette sauvegarde incrémentale montre que la plupart des fichiers sont copiés depuis <span class="host">pg-standby</span> et que seuls quelques-uns sont copiés depuis <span class="host">pg-primary</span>.</div><div class="section-body-text"><span class="backrest">pgBackRest</span> crée une sauvegarde depuis l'instance esclave qui est identique à une sauvegarde effectuée sur l'instance primaire. Pour ce faire, il lance/arrête la sauvegarde sur l'hôte <span class="host">{[hôte-pg1]}</span>, en copiant uniquement les fichiers qui sont répliqués à partir de l'hôte <span class="host">{[hôte-pg2]}</span>, puis en copiant les quelques fichiers restants à partir de l'hôte <span class="host">{[hôte-pg1]}</span>. Cela signifie que les journaux et les statistiques de la base de données principale seront inclus dans la sauvegarde.</div></div></div><div class="section1"><a id="upgrade-stanza"></a><div class="section1-header"><div class="section1-number">20</div><div class="section1-title">Mise à niveau de <span class="postgres">PostgreSQL</span></div></div><div class="section-body"><div class="section-body-text">Immediately after upgrading <span class="postgres">PostgreSQL</span> to a newer major version, the <span class="br-option">pg-path</span> for all <span class="backrest">pgBackRest</span> configurations must be set to the new database location and the <span class="cmd">stanza-upgrade</span> run on the repository host. If the database is offline use the <span class="br-option">--no-online</span> option.</div><div class="section-body-text">Les instructions suivantes ne se veulent pas un guide complet pour la mise à niveau de <span class="postgres">PostgreSQL</span>, mais elles décrivent plutôt le processus général de mise à niveau d'une instance <span class="postgres">PostgreSQL</span> primaire et d'une instance <span class="postgres">PostgreSQL</span> esclave (standb) dans le but de présenter les étapes nécessaires dans la reconfiguration de <span class="postgres">PostgreSQL</span>. Il est recommandé d'effectuer une sauvegarde avant la mise à niveau.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Arrêter la vieille instance</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre></div></div><div class="section-body-text">Arrêtez l'instance esclave (standb), car elle sera restaurée à partir de la l'instance nouvellement mise à niveau.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Arrêter la vieille instance</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl stop postgresql-9.6.service</pre></div></div><div class="section-body-text">Créer une nouvelle instance et effectuer la mise à niveau.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Créer une nouvelle instance et effectuer la mise à niveau</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres /usr/pgsql-10/bin/initdb \
       -D /var/lib/pgsql/10/data -k -A peer</pre><pre class="execute-body-cmd">sudo -u postgres sh -c 'cd /var/lib/pgsql &amp;&amp; \
       /usr/pgsql-10/bin/pg_upgrade \
       --old-bindir=/usr/pgsql-9.6/bin \
       --new-bindir=/usr/pgsql-10/bin \
       --old-datadir=/var/lib/pgsql/9.6/data \
       --new-datadir=/var/lib/pgsql/10/data \
       --old-options=" -c config_file=/var/lib/pgsql/9.6/data/postgresql.conf" \
       --new-options=" -c config_file=/var/lib/pgsql/10/data/postgresql.conf"'</pre><pre class="execute-body-output">       [filtered 70 lines of output]
Checking for hash indexes                                   ok
</pre><pre class="execute-body-output-highlight">Upgrade Complete</pre><pre class="execute-body-output">----------------
Optimizer statistics are not transferred by pg_upgrade so,
       [filtered 4 lines of output]</pre></div></div><div class="section-body-text">Configuration des paramètres et du port de la nouvelle instance.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/var/lib/pgsql/10/data/postgresql.conf</span> <b>&#x21d2;</b> Configuration de <span class="postgres">PostgreSQL</span></div><div class="config-body"><div class="config-body-output">archive_command = 'pgbackrest --stanza=demo archive-push %p'<br/>
archive_mode = on<br/>
listen_addresses = '*'<br/>
log_line_prefix = ''<br/>
max_wal_senders = 3<br/>
port = 5432<br/>
wal_level = replica</div></div></div><div class="section-body-text">Mettez à jour la configuration <span class="backrest">pgBackRest</span> sur tous les systèmes pour pointer vers la nouvelle instance.</div><div class="config"><div class="config-title"><span class="host">pg-primary</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Mise à jour de <span class="br-option">pg1-path</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/10/data<br/>
<br/>
[global]<br/>
archive-async=y<br/>
log-level-file=detail<br/>
repo1-host=repository<br/>
spool-path=/var/spool/pgbackrest<br/>
<br/>
[global:archive-get]<br/>
process-max=2<br/>
<br/>
[global:archive-push]<br/>
process-max=2</div></div></div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Mise à jour de <span class="br-option">pg-path</span></div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-path=/var/lib/pgsql/10/data<br/>
recovery-option=primary_conninfo=host=172.17.0.4 port=5432 user=replicator<br/>
<br/>
[global]<br/>
archive-async=y<br/>
log-level-file=detail<br/>
repo1-host=repository<br/>
spool-path=/var/spool/pgbackrest<br/>
<br/>
[global:archive-get]<br/>
process-max=2<br/>
<br/>
[global:archive-push]<br/>
process-max=2</div></div></div><div class="config"><div class="config-title"><span class="host">repository</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Upgrade <span class="br-option">pg1-path</span> and <span class="br-option">pg2-path</span>, disable backup from standby</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-host=pg-primary<br/>
pg1-path=/var/lib/pgsql/10/data<br/>
pg2-host=pg-standby<br/>
pg2-path=/var/lib/pgsql/10/data<br/>
<br/>
[global]<br/>
backup-standby=n<br/>
process-max=3<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y</div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Copie de la configuration hba</div><div class="execute-body"><pre class="execute-body-cmd">sudo cp /var/lib/pgsql/9.6/data/pg_hba.conf \
       /var/lib/pgsql/10/data/pg_hba.conf</pre></div></div><div class="section-body-text">Avant de lancer la nouvelle instance, la commande <span class="cmd">stanza-upgrade</span> doit être exécutée sur le serveur où se trouve le dépôt <span class="backrest">pgBackRest</span>.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Mise à niveau du stanza</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo --no-online \
       --log-level-console=info stanza-upgrade</pre><pre class="execute-body-output">P00   INFO: stanza-upgrade command begin 2.25: --no-backup-standby --log-level-console=info --log-level-stderr=off --no-log-timestamp --no-online --pg1-host=pg-primary --pg2-host=pg-standby --pg1-path=/var/lib/pgsql/10/data --pg2-path=/var/lib/pgsql/10/data --repo1-path=/var/lib/pgbackrest --stanza=demo</pre><pre class="execute-body-output-highlight">P00   INFO: stanza-upgrade command end: completed successfully</pre></div></div><div class="section-body-text">Démarrer la nouvelle instance et confirmer qu'il est installé avec succès.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Démarrage de la nouvelle instance</div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-10.service</pre></div></div><div class="section-body-text">Controler la configuration en utilisant la commande <span class="cmd">check</span>.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Controle de la configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres systemctl status postgresql-10.service</pre><pre class="execute-body-output">● postgresql-10.service - PostgreSQL 10 database server
   Loaded: loaded (/usr/lib/systemd/system/postgresql-10.service; disabled; vendor preset: disabled)
   Active: active (running) since Wed 2020-04-08 11:14:11 UTC; 384ms ago
     Docs: https://www.postgresql.org/docs/10/static/
  Process: 4293 ExecStartPre=/usr/pgsql-10/bin/postgresql-10-check-db-dir ${PGDATA} (code=exited, status=0/SUCCESS)
 Main PID: 4298 (postmaster)
   CGroup: /docker/b73e30e135c2c7336eb7ae547aa76f60b0e1852c13d5a529ba63af0b39409aad/system.slice/postgresql-10.service
           ├─4298 /usr/pgsql-10/bin/postmaster -D /var/lib/pgsql/10/data/
           ├─4299 postgres: logger process                               
           ├─4301 postgres: checkpointer process                         
           ├─4302 postgres: writer process                               
           ├─4303 postgres: wal writer process                           
           ├─4304 postgres: autovacuum launcher process                  
           ├─4305 postgres: archiver process                             
           ├─4306 postgres: stats collector process                      
           └─4307 postgres: bgworker: logical replication launcher       </pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo check</pre></div></div><div class="section-body-text">Supprimer l'ancienne instance.</div><div class="execute"><div class="execute-title"><span class="host">pg-primary</span> <b>&#x21d2;</b> Suppression de l'ancienne instance</div><div class="execute-body"><pre class="execute-body-cmd">sudo rm -rf /var/lib/pgsql/9.6/data</pre></div></div><div class="section-body-text">Installer la nouvelle version des binaire de <span class="postgres">PostgreSQL</span> sur l'esclave (standby) et créer l'instance.</div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Supprimer l'ancienne instance et créer une nouvelle instance</div><div class="execute-body"><pre class="execute-body-cmd">sudo rm -rf /var/lib/pgsql/9.6/data</pre><pre class="execute-body-cmd">sudo -u postgres mkdir -p -m 700 /usr/pgsql-10/bin</pre></div></div><div class="section-body-text">Exécuter la commande <span class="cmd">check</span> sur l'hôte du dépôt. L'avertissement concernant l'instance esclave est attendu puisque l'instance est en panne. L'exécution de cette commande permet de démontrer que le serveur de dépôt est conscient de l'existance d'un serveur esclave et que <span class="backrest">pgBackRest</span> est bien configuré pour l'instance primaire.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Controle de la configuration</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo check</pre><pre class="execute-body-output">P00   WARN: unable to check pg-2: [DbConnectError] raised from remote-0 protocol on 'pg-standby': unable to connect to 'dbname='postgres' port=5432': could not connect to server: No such file or directory
            	Is the server running locally and accepting
            	connections on Unix domain socket "/var/run/postgresql/.s.PGSQL.5432"?</pre></div></div><div class="section-body-text">Effectuez une sauvegarde complète sur la nouvelle instance, puis restaurez la sur l'instance secondaire (standby) à partir de cette sauvegarde. Le type de sauvegarde sera automatiquement changé en <span class="id">full</span> si <span class="id">incr</span> ou <span class="id">diff</span> est demandé.</div><div class="execute"><div class="execute-title"><span class="host">repository</span> <b>&#x21d2;</b> Démarrage d'une sauvegarde complète</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u pgbackrest pgbackrest --stanza=demo --type=full backup</pre></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Restauration de demo sur l'instance esclave</div><div class="execute-body"><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo --type=standby restore</pre></div></div><div class="config"><div class="config-title"><span class="host">pg-standby</span>:<span class="file">/var/lib/pgsql/10/data/postgresql.conf</span> <b>&#x21d2;</b> Configuration de <span class="postgres">PostgreSQL</span></div><div class="config-body"><div class="config-body-output">hot_standby = on</div></div></div><div class="execute"><div class="execute-title"><span class="host">pg-standby</span> <b>&#x21d2;</b> Démarrer <span class="postgres">PostgreSQL</span> et controler la configuration de <span class="backrest">pgBackRest</span></div><div class="execute-body"><pre class="execute-body-cmd">sudo systemctl start postgresql-10.service</pre><pre class="execute-body-cmd">sudo -u postgres pgbackrest --stanza=demo check</pre></div></div><div class="section-body-text">La sauvegarde à partir de l'esclave peut être activée maintenant que cette esclave a été remis en place.</div><div class="config"><div class="config-title"><span class="host">repository</span>:<span class="file">/etc/pgbackrest/pgbackrest.conf</span> <b>&#x21d2;</b> Réactivation de la sauvegarde depuis l'esclave</div><div class="config-body"><div class="config-body-output">[demo]<br/>
pg1-host=pg-primary<br/>
pg1-path=/var/lib/pgsql/10/data<br/>
pg2-host=pg-standby<br/>
pg2-path=/var/lib/pgsql/10/data<br/>
<br/>
[global]<br/>
backup-standby=y<br/>
process-max=3<br/>
repo1-path=/var/lib/pgbackrest<br/>
repo1-retention-full=2<br/>
start-fast=y</div></div></div></div></div></div><div class="page-footer">Copyright &copy; 2015-2020, The PostgreSQL Global Development Group, <a href="https://github.com/pgbackrest/pgbackrest/blob/master/LICENSE">MIT License</a>.  Updated April 8, 2020</div></body></html>